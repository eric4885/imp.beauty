<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    
    <title>Imp Beauty - The Ultimate Imp Spider Solitaire Game</title>
    <meta name="description" content="Play Imp Beauty, a modern and elegant spider solitaire game. Enjoy a minimalist design with smooth gameplay on both desktop and mobile devices.">
    <link rel="canonical" href="https://imp.beauty/">

    <meta property="og:title" content="Imp Beauty - The Ultimate Imp Spider Solitaire Game">
    <meta property="og:description" content="Play Imp Beauty, a modern and elegant spider solitaire game. Enjoy a minimalist design with smooth gameplay on both desktop and mobile devices.">
    <meta property="og:url" content="https://imp.beauty/">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://imp.beauty/social-share-image.jpg">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Apple-inspired colors */
        :root {
            --color-dark-bg: #1C1C1E;
            --color-light-text: #F2F2F7;
            --color-accent-blue: #0A84FF;
            --color-accent-green: #30D158;
            --color-card-bg: #2C2C2E;
            --color-accent-purple: #AF52DE;
            --color-accent-orange: #FF9500;
            
            /* Game-specific variables */
            --card-width: 70px;
            --card-height: calc(var(--card-width) * 1.4);
            --card-radius: 8px;
            --card-bg-light: #F9FAFB;
            --card-bg-dark: var(--color-card-bg);
            --card-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            --red-suit: #FF3B30;
            --black-suit: #1C1C1E;
        }

        body {
            background-color: var(--color-dark-bg);
            color: var(--color-light-text);
            touch-action: manipulation;
        }

        /* Game state transitions */
        .landing-state {
            display: block;
        }
        .game-state {
            display: none;
        }
        
        .game-active .landing-state {
            display: none;
        }
        .game-active .game-state {
            display: block;
        }

        /* Hero section animations */
        .hero-title {
            background: linear-gradient(135deg, var(--color-accent-green), var(--color-accent-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { filter: brightness(1); }
            to { filter: brightness(1.2); }
        }

        .play-button {
            background: linear-gradient(135deg, var(--color-accent-green), var(--color-accent-blue));
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 10px 25px rgba(48, 209, 88, 0.3);
        }

        .play-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 20px 40px rgba(48, 209, 88, 0.4);
        }

        /* Card game styles */
        .card-container {
            width: var(--card-width);
            height: var(--card-height);
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            cursor: pointer;
            perspective: 1000px;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .card-container.transitioning {
            transition: transform 0.6s, top 0.3s ease, left 0.3s ease;
        }

        .card-container.dragging {
            z-index: 1000 !important;
            pointer-events: none;
            opacity: 0.8;
            transform: scale(1.02);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: var(--card-radius);
            box-shadow: var(--card-shadow);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }

        .card-front {
            background-color: var(--card-bg-light);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: var(--black-suit);
        }
        .card-front.is-red {
            color: var(--red-suit);
        }
        .card-front .card-value {
            font-size: 1.2rem;
            font-weight: bold;
            line-height: 1;
        }
        .card-front .suit-symbol {
             font-size: 1.5rem;
        }

        .card-back {
            background: linear-gradient(135deg, var(--color-card-bg), #3A3A3C);
            transform: rotateY(180deg);
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card-container.is-flipped {
            transform: rotateY(0deg);
        }

        .card-container:not(.is-flipped) {
            transform: rotateY(180deg);
        }

        .tableau-pile {
            position: relative;
            padding-top: 15px;
            min-height: calc(var(--card-height) + 80px);
            border: 2px dashed transparent;
            border-radius: var(--card-radius);
            transition: border-color 0.2s;
            /* ç¡®ä¿æœ‰è¶³å¤Ÿçš„ç‚¹å‡»åŒºåŸŸ */
            padding-bottom: 60px;
        }

        .tableau-pile.drag-over {
            border-color: var(--color-accent-blue);
            background-color: rgba(10, 132, 255, 0.1);
        }

        .tableau-pile .card-container {
            position: absolute;
            top: 0;
            left: 0;
            transition: top 0.3s ease;
        }

        #stock-pile {
            width: var(--card-width);
            height: var(--card-height);
            position: relative;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        #stock-pile:hover {
            transform: scale(1.05);
        }

        #stock-pile .card-back {
            position: absolute;
            top: 0;
            left: 0;
        }

        #foundations {
            display: flex;
            gap: 8px;
        }
        .foundation-pile {
             width: var(--card-width);
             height: var(--card-height);
             border: 2px solid rgba(255, 255, 255, 0.3);
             border-radius: var(--card-radius);
             display: flex;
             align-items: center;
             justify-content: center;
        }
        .foundation-pile .card-container {
            position: relative;
        }

        .foundation-pile.empty {
            background-color: rgba(255, 255, 255, 0.05);
        }

        #game-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            color: var(--color-light-text);
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }

        #fireworks {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
            z-index: 9999;
        }
        
        #win-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 0 0 10px black;
            display: none;
            text-align: center;
            z-index: 10000;
            background: linear-gradient(135deg, rgba(48, 209, 88, 0.9), rgba(10, 132, 255, 0.9));
            padding: 2rem;
            border-radius: 20px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn {
            background: var(--color-accent-blue);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border: none;
            color: white;
            font-weight: 500;
        }
        .btn:hover { 
            background: #0056CC;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(10, 132, 255, 0.3);
        }
        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            :root {
                --card-width: 60px;
            }
            .card-front .card-value {
                font-size: 1rem;
            }
            .card-front .suit-symbol {
                font-size: 1.2rem;
            }
            .hero-title {
                font-size: 3rem !important;
            }
        }

        /* Animations */
        @media (prefers-reduced-motion: reduce) {
            .card-container {
                transition: none;
            }
        }

        .fade-in {
            animation: fadeIn 0.6s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: var(--color-dark-bg);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--color-accent-blue);
            border-radius: 4px;
        }
    </style>
</head>
<body class="font-sans antialiased text-white">

    <!-- Landing Page State -->
    <div class="landing-state">
        <div class="min-h-screen flex flex-col items-center justify-center p-4">
            <header class="text-center mb-8">
                <h1 class="hero-title text-6xl md:text-8xl font-bold tracking-tight">Imp Beauty</h1>
                <p class="mt-4 text-lg md:text-xl font-light text-gray-400">The most elegant spider solitaire game you'll ever play.</p>
            </header>

            <main class="w-full max-w-2xl text-center">
                <p class="text-xl md:text-2xl font-medium leading-relaxed mb-8">
                    Unwind with <span style="color: var(--color-accent-blue);" class="font-bold">Imp Beauty</span>, a beautifully designed spider solitaire experience. With a minimalist interface and fluid animations, it's the perfect way to pass the time.
                </p>

                <div class="mb-8">
                    <button id="start-game-btn" class="play-button text-white text-xl font-bold py-4 px-8 rounded-2xl">
                        ğŸ´ Start Playing
                    </button>
                </div>

                <div id="game-preview" class="w-full bg-gray-800 rounded-2xl shadow-xl border-4 mb-12" style="border-color: var(--color-card-bg);">
                    <div class="h-96 md:h-[500px] flex items-center justify-center text-xl font-semibold text-gray-400 p-8">
                        <div class="text-center">
                            <div class="text-6xl mb-4">ğŸ´</div>
                            <div class="text-lg">Click "Start Playing" to begin your adventure</div>
                            <div class="text-sm text-gray-500 mt-2">No registration required â€¢ Play instantly</div>
                        </div>
                    </div>
                </div>

                <div class="text-left space-y-6">
                    <h2 class="text-3xl font-bold" style="color: var(--color-accent-blue);">Game Overview</h2>
                    <p class="text-base leading-relaxed text-gray-400">
                        <strong class="text-white">Imp Beauty</strong> is a modern take on the classic spider solitaire game. The goal is to create sets of cards from King to Ace, which are then removed from the tableau. The game is designed for a seamless experience on any device, from a large desktop monitor to a smartphone.
                    </p>
                    
                    <h3 class="text-2xl font-bold text-white">How to Play</h3>
                    <ul class="list-disc list-inside space-y-2 text-base text-gray-400">
                        <li><strong class="text-white">Goal:</strong> Remove all cards by building complete sequences from King to Ace in the same suit.</li>
                        <li><strong class="text-white">Card Movement:</strong> Cards can be moved in descending order (King, Queen, Jack, 10, etc.) regardless of suit.</li>
                        <li><strong class="text-white">Sequence Building:</strong> Only complete same-suit sequences from King to Ace are removed.</li>
                        <li><strong class="text-white">Stock Pile:</strong> Click to deal one card to each column when you're stuck.</li>
                        <li><strong class="text-white">Empty Columns:</strong> Any card or valid sequence can be placed in an empty column.</li>
                    </ul>
                    
                    <h3 class="text-2xl font-bold text-white">Features</h3>
                    <ul class="list-disc list-inside space-y-2 text-base text-gray-400">
                        <li><strong class="text-white">Fluid Gameplay:</strong> Drag and drop cards with smooth, intuitive controls.</li>
                        <li><strong class="text-white">Minimalist Design:</strong> A clean interface that lets you focus on the game, not the clutter.</li>
                        <li><strong class="text-white">Adaptive Display:</strong> Automatically adjusts to your screen size for optimal play.</li>
                        <li><strong class="text-white">Offline Mode:</strong> Play anytime, anywhere, with no internet required.</li>
                        <li><strong class="text-white">Score System:</strong> Challenge yourself with our intelligent scoring system.</li>
                        <li><strong class="text-white">Hint System:</strong> Get helpful suggestions when you're stuck.</li>
                        <li><strong class="text-white">Auto-flip:</strong> Face-down cards are automatically revealed when exposed.</li>
                    </ul>
                    
                    <h3 class="text-2xl font-bold text-white">Tips for Success</h3>
                    <ul class="list-disc list-inside space-y-2 text-base text-gray-400">
                        <li><strong class="text-white">Plan Ahead:</strong> Try to expose face-down cards by moving the cards on top of them.</li>
                        <li><strong class="text-white">Build in Suit:</strong> Whenever possible, build sequences in the same suit for easier completion.</li>
                        <li><strong class="text-white">Use Empty Columns:</strong> Empty columns are valuable for temporarily storing cards.</li>
                        <li><strong class="text-white">Don't Rush:</strong> Take your time to consider all possible moves before dealing new cards.</li>
                    </ul>
                </div>
            </main>

            <footer class="mt-12 text-center text-sm font-light text-gray-500">
                <p>&copy; 2025 Imp.Beauty. All rights reserved.</p>
            </footer>
        </div>
    </div>

    <!-- Game State -->
    <div class="game-state">
        <div class="p-4 md:p-6 max-w-7xl mx-auto">
            <!-- Game Header -->
            <div class="text-center mb-6">
                <h1 class="text-2xl md:text-3xl font-bold" style="color: var(--color-accent-green);">Imp Beauty</h1>
                <button id="back-to-landing" class="mt-2 text-sm text-gray-400 hover:text-white transition-colors">â† Back to Home</button>
            </div>

            <!-- Game Stats -->
            <div id="game-stats" class="flex justify-between items-center mb-4 text-sm">
                <div class="flex gap-4">
                    <span id="moves-counter">æ­¥æ•°: 0</span>
                    <span id="timer-counter">æ—¶é—´: 00:00</span>
                    <span id="score-counter">å¾—åˆ†: 0</span>
                </div>
                <div class="flex gap-2">
                    <button id="hint-btn" class="btn btn-secondary">ğŸ’¡ æç¤º</button>
                    <button id="restart-btn-top" class="btn">ğŸ”„ é‡æ–°å¼€å§‹</button>
                </div>
            </div>
            
            <!-- Stock and Foundations -->
            <div class="flex justify-between items-start mb-4">
                <div class="flex flex-col items-center">
                    <div id="stock-pile">
                        <div class="card-face card-back">
                             <span class="text-white text-sm font-bold">IMP</span>
                        </div>
                    </div>
                    <div class="text-center text-xs text-gray-400 mt-1">
                        å‰©ä½™: <span id="stock-count">50</span>
                    </div>
                </div>
                
                <div id="foundations" class="flex flex-wrap justify-end gap-1">
                    <!-- Foundation piles will be rendered here -->
                </div>
            </div>

            <!-- Game Board -->
            <div id="game-board" class="grid grid-cols-5 md:grid-cols-10 gap-1 md:gap-2">
                <div id="pile-0" class="tableau-pile"></div>
                <div id="pile-1" class="tableau-pile"></div>
                <div id="pile-2" class="tableau-pile"></div>
                <div id="pile-3" class="tableau-pile"></div>
                <div id="pile-4" class="tableau-pile"></div>
                <div id="pile-5" class="tableau-pile"></div>
                <div id="pile-6" class="tableau-pile"></div>
                <div id="pile-7" class="tableau-pile"></div>
                <div id="pile-8" class="tableau-pile"></div>
                <div id="pile-9" class="tableau-pile"></div>
            </div>
        </div>
    </div>
    
    <!-- Game Win Elements -->
    <canvas id="fireworks"></canvas>
    <div id="win-message">
        ğŸ‰ æ­å–œè·èƒœï¼ ğŸ‰<br>
        <div class="mt-4 text-base font-normal">
            å®Œæˆæ—¶é—´: <span id="final-time"></span><br>
            æ€»æ­¥æ•°: <span id="final-moves"></span><br>
            æœ€ç»ˆå¾—åˆ†: <span id="final-score"></span>
        </div>
        <div class="mt-6 flex gap-3 justify-center">
            <button id="restart-btn-win" class="btn">ğŸ® å†ç©ä¸€å±€</button>
            <button id="back-to-home-win" class="btn btn-secondary">ğŸ  è¿”å›é¦–é¡µ</button>
        </div>
    </div>

    <script>
        class Card {
            constructor(suit, value, name) {
                this.suit = suit;
                this.value = value;
                this.name = name;
                this.isFaceUp = false;
                this.id = `${suit}_${value}_${Math.random().toString(36).substr(2, 9)}`;
            }
        }

        class SpiderSolitaire {
            constructor() {
                console.log('SpiderSolitaire æ„é€ å‡½æ•°è¢«è°ƒç”¨'); // è°ƒè¯•æ—¥å¿—
                this.gameState = null;
                this.timerInterval = null;
                this.startTime = null;
                this.draggedCards = null;
                this.originalPileIndex = null;
                this.originalCardIndex = null;
                this.originalPositions = [];
                this.isDragging = false;
                this.animationFrameId = null;
                
                console.log('å¼€å§‹åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨'); // è°ƒè¯•æ—¥å¿—
                this.initializeEventListeners();
                console.log('äº‹ä»¶ç›‘å¬å™¨åˆå§‹åŒ–å®Œæˆ'); // è°ƒè¯•æ—¥å¿—
            }

            createAndShuffleDeck() {
                const suits = ['spades', 'hearts', 'clubs', 'diamonds'];
                const values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];
                const cardNames = {
                    1: 'A', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7',
                    8: '8', 9: '9', 10: '10', 11: 'J', 12: 'Q', 13: 'K'
                };

                let deck = [];
                for (let i = 0; i < 2; i++) {
                    for (const suit of suits) {
                        for (const value of values) {
                            deck.push(new Card(suit, value, cardNames[value]));
                        }
                    }
                }
                
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
                
                return deck;
            }

            initializeGame(shuffledDeck = null) {
                console.log('åˆå§‹åŒ–æ¸¸æˆå¼€å§‹'); // è°ƒè¯•æ—¥å¿—
                
                if (!shuffledDeck) {
                    shuffledDeck = this.createAndShuffleDeck();
                }

                console.log('åˆ›å»ºäº†', shuffledDeck.length, 'å¼ ç‰Œ'); // è°ƒè¯•æ—¥å¿—

                this.gameState = {
                    tableauPiles: Array.from({ length: 10 }, () => []),
                    stockPiles: [],
                    foundations: [],
                    moves: 0,
                    score: 500,
                    completedSequences: 0
                };

                let cardIndex = 0;
                const cardsPerPile = [6, 6, 6, 6, 5, 5, 5, 5, 5, 5];

                // åˆ†å‘åˆå§‹ç‰Œ
                for (let pileIndex = 0; pileIndex < 10; pileIndex++) {
                    console.log(`ä¸ºæ¡© ${pileIndex} åˆ†å‘ ${cardsPerPile[pileIndex]} å¼ ç‰Œ`);
                    for (let i = 0; i < cardsPerPile[pileIndex]; i++) {
                        if (cardIndex < shuffledDeck.length) {
                            let card = shuffledDeck[cardIndex];
                            this.gameState.tableauPiles[pileIndex].push(card);
                            cardIndex++;
                        }
                    }
                    // ç¿»å¼€æ¯å †çš„é¡¶ç‰Œ
                    let topCard = this.gameState.tableauPiles[pileIndex][this.gameState.tableauPiles[pileIndex].length - 1];
                    if (topCard) {
                        topCard.isFaceUp = true;
                        console.log(`æ¡© ${pileIndex} é¡¶ç‰Œ ${topCard.name} å·²ç¿»å¼€`);
                    }
                }
                
                // å‰©ä½™çš„ç‰Œæ”¾å…¥åº“å­˜
                this.gameState.stockPiles = shuffledDeck.slice(cardIndex);
                console.log('åº“å­˜ç‰Œæ•°:', this.gameState.stockPiles.length);
                
                // éªŒè¯åˆ†å‘ç»“æœ
                const totalCards = this.gameState.tableauPiles.reduce((sum, pile) => sum + pile.length, 0) + this.gameState.stockPiles.length;
                console.log('æ€»ç‰Œæ•°éªŒè¯:', totalCards, 'åº”ä¸º 104');
                
                this.startTimer();
                
                console.log('æ¸¸æˆåˆå§‹åŒ–å®Œæˆï¼Œå‡†å¤‡æ¸²æŸ“');
                // ä¸åœ¨è¿™é‡Œè°ƒç”¨ renderGameï¼Œç”± startGame è°ƒç”¨
            }

            startTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                this.startTime = Date.now();
                this.timerInterval = setInterval(() => this.updateTimer(), 1000);
            }

            updateTimer() {
                if (!this.startTime) return;
                
                const elapsedTime = Date.now() - this.startTime;
                const minutes = Math.floor(elapsedTime / 60000);
                const seconds = Math.floor((elapsedTime % 60000) / 1000);
                
                const formattedMinutes = String(minutes).padStart(2, '0');
                const formattedSeconds = String(seconds).padStart(2, '0');
                
                document.getElementById('timer-counter').textContent = `æ—¶é—´: ${formattedMinutes}:${formattedSeconds}`;
            }

            renderGame() {
                console.log('å¼€å§‹æ¸²æŸ“æ¸¸æˆ'); // è°ƒè¯•æ—¥å¿—
                if (!this.gameState) {
                    console.error('æ¸¸æˆçŠ¶æ€ä¸ºç©ºï¼Œæ— æ³•æ¸²æŸ“');
                    return;
                }

                console.log('æ¸²æŸ“æ¸¸æˆçŠ¶æ€:', {
                    moves: this.gameState.moves,
                    score: this.gameState.score,
                    stockPiles: this.gameState.stockPiles.length,
                    tableauPiles: this.gameState.tableauPiles.map(pile => pile.length)
                });

                this.updateGameStats();
                this.renderStockPile();
                this.renderFoundations();
                this.renderTableauPiles();
                
                console.log('æ¸¸æˆæ¸²æŸ“å®Œæˆ');
            }

            updateGameStats() {
                document.getElementById('moves-counter').textContent = `æ­¥æ•°: ${this.gameState.moves}`;
                document.getElementById('score-counter').textContent = `å¾—åˆ†: ${this.gameState.score}`;
                document.getElementById('stock-count').textContent = this.gameState.stockPiles.length;
            }

            renderStockPile() {
                const stockPileElement = document.getElementById('stock-pile');
                if (this.gameState.stockPiles.length > 0) {
                    stockPileElement.style.opacity = '1';
                    stockPileElement.style.cursor = 'pointer';
                } else {
                    stockPileElement.style.opacity = '0.5';
                    stockPileElement.style.cursor = 'not-allowed';
                }
            }

            renderFoundations() {
                const foundationsElement = document.getElementById('foundations');
                foundationsElement.innerHTML = '';
                
                this.gameState.foundations.forEach((foundationPile, index) => {
                    const foundationContainer = document.createElement('div');
                    foundationContainer.className = 'foundation-pile';
                    
                    if (foundationPile.length > 0) {
                        const topCard = foundationPile[foundationPile.length - 1];
                        const isRed = topCard.suit === 'hearts' || topCard.suit === 'diamonds';
                        const suitSymbols = { 'spades': 'â™ ', 'hearts': 'â™¥', 'clubs': 'â™£', 'diamonds': 'â™¦' };
                        
                        foundationContainer.innerHTML = `
                            <div class="card-container is-flipped">
                                <div class="card-face card-back"></div>
                                <div class="card-face card-front ${isRed ? 'is-red' : ''}">
                                    <span class="card-value self-start p-1">${topCard.name}</span>
                                    <span class="suit-symbol">${suitSymbols[topCard.suit]}</span>
                                    <span class="card-value self-end p-1 rotate-180">${topCard.name}</span>
                                </div>
                            </div>
                        `;
                    } else {
                        foundationContainer.classList.add('empty');
                        foundationContainer.innerHTML = '<span class="text-gray-500 text-xs">å®Œæˆæ¡©</span>';
                    }
                    
                    foundationsElement.appendChild(foundationContainer);
                });
            }

            renderTableauPiles() {
                console.log('å¼€å§‹æ¸²æŸ“tableau piles');
                
                this.gameState.tableauPiles.forEach((pile, pileIndex) => {
                    const pileElement = document.getElementById(`pile-${pileIndex}`);
                    if (!pileElement) {
                        console.error(`æ‰¾ä¸åˆ°æ¡©å…ƒç´ : pile-${pileIndex}`);
                        return;
                    }
                    
                    console.log(`æ¸²æŸ“æ¡© ${pileIndex}ï¼ŒåŒ…å« ${pile.length} å¼ ç‰Œ`);
                    pileElement.innerHTML = '';
                    
                    pile.forEach((card, cardIndex) => {
                        const cardContainer = document.createElement('div');
                        cardContainer.className = 'card-container';
                        
                        // ç¿»å¼€çš„ç‰Œæ·»åŠ is-flippedç±»
                        if (card.isFaceUp) {
                            cardContainer.classList.add('is-flipped');
                            console.log(`ç‰Œ ${card.name}${card.suit} å·²ç¿»å¼€`);
                        }
                        
                        cardContainer.dataset.cardIndex = cardIndex.toString();
                        cardContainer.dataset.pileIndex = pileIndex.toString();
                        cardContainer.dataset.cardId = card.id;
                        
                        const topOffset = cardIndex * 15;
                        cardContainer.style.top = `${topOffset}px`;
                        cardContainer.style.position = 'absolute';
                        cardContainer.style.left = '0px';
                        
                        const isRed = card.suit === 'hearts' || card.suit === 'diamonds';
                        
                        // ä½¿ç”¨è¾…åŠ©å‡½æ•°ç”Ÿæˆå¡ç‰‡HTML
                        cardContainer.innerHTML = this.generateCardHTML(card, isRed);

                        if (card.isFaceUp) {
                            cardContainer.style.cursor = 'grab';
                            cardContainer.setAttribute('draggable', 'false');
                        } else {
                            cardContainer.style.cursor = 'default';
                        }

                        pileElement.appendChild(cardContainer);
                    });
                });
                
                console.log('tableau piles æ¸²æŸ“å®Œæˆ');
            }

            // ä¿®å¤çš„å®Œæ•´åºåˆ—æ£€æŸ¥é€»è¾‘
            checkCompleteSequence(pile) {
                if (pile.length < 13) return false;
                
                // æ£€æŸ¥æœ€å13å¼ ç‰Œæ˜¯å¦ç»„æˆå®Œæ•´åºåˆ— (Kåˆ°Aï¼ŒåŒèŠ±è‰²)
                const sequence = pile.slice(-13);
                const suit = sequence[0].suit; // ç¬¬ä¸€å¼ ç‰Œ(K)çš„èŠ±è‰²
                
                // æ£€æŸ¥æ˜¯å¦ä¸ºKåˆ°Açš„é€’å‡åºåˆ—ï¼Œä¸”åŒèŠ±è‰²
                for (let i = 0; i < 13; i++) {
                    const expectedValue = 13 - i; // K=13, Q=12, ..., A=1
                    const card = sequence[i];
                    
                    if (card.value !== expectedValue || card.suit !== suit) {
                        return false;
                    }
                }
                
                return true;
            }

            // ä¿®å¤çš„æœ‰æ•ˆæ‹–æ‹½åºåˆ—æ£€æŸ¥
            isValidDragSequence(cards) {
                if (!cards || cards.length === 0) return false;
                if (cards.length === 1) return true;
                
                // æ£€æŸ¥æ˜¯å¦ä¸ºåŒèŠ±è‰²é€’å‡åºåˆ—
                const suit = cards[0].suit;
                
                for (let i = 0; i < cards.length - 1; i++) {
                    const currentCard = cards[i];
                    const nextCard = cards[i + 1];
                    
                    // å¿…é¡»æ˜¯åŒèŠ±è‰²ä¸”é€’å‡(å½“å‰ç‰Œå€¼-1 = ä¸‹ä¸€å¼ ç‰Œå€¼)
                    if (currentCard.suit !== suit || 
                        nextCard.suit !== suit ||
                        currentCard.value !== nextCard.value + 1) {
                        return false;
                    }
                }
                return true;
            }

            // ä¿®å¤çš„æœ‰æ•ˆç§»åŠ¨æ£€æŸ¥
            isValidMove(draggedCardsData, targetPileIndex) {
                if (!draggedCardsData || draggedCardsData.length === 0) return false;
                if (targetPileIndex < 0 || targetPileIndex >= 10) return false;
                
                const targetPile = this.gameState.tableauPiles[targetPileIndex];
                const firstDraggedCard = draggedCardsData[0];
                
                // ç©ºæ¡©å¯ä»¥æ”¾ä»»ä½•ç‰Œ
                if (targetPile.length === 0) {
                    return true;
                }

                const topCardOfTargetPile = targetPile[targetPile.length - 1];
                // å¿…é¡»ç¿»å¼€ä¸”æ•°å€¼é€’å‡(ç›®æ ‡æ¡©é¡¶ç‰Œå€¼-1 = æ‹–æ‹½ç‰Œå€¼)
                return topCardOfTargetPile.isFaceUp && 
                       firstDraggedCard.value === topCardOfTargetPile.value - 1;
            }

            getDropTarget(x, y) {
                console.log('æ£€æµ‹æ‹–æ”¾ç›®æ ‡ï¼Œåæ ‡:', x, y); // è°ƒè¯•æ—¥å¿—
                
                if (!x || !y) {
                    console.log('æ— æ•ˆåæ ‡'); // è°ƒè¯•æ—¥å¿—
                    return null;
                }
                
                // ä¸´æ—¶éšè—æ‹–æ‹½å…ƒç´ ä»¥é¿å…å¹²æ‰°æ£€æµ‹
                const originalDisplay = [];
                if (this.draggedCards) {
                    this.draggedCards.forEach((card, index) => {
                        originalDisplay[index] = card.style.display;
                        card.style.display = 'none';
                    });
                }
                
                let targetPile = null;
                
                // ä½¿ç”¨elementsFromPointæ£€æµ‹
                try {
                    const elements = document.elementsFromPoint(x, y);
                    console.log('åæ ‡ä¸‹çš„å…ƒç´ :', elements.map(el => el.className || el.tagName).slice(0, 5)); // åªæ˜¾ç¤ºå‰5ä¸ª
                    
                    for (const element of elements) {
                        const pile = element.closest('.tableau-pile');
                        if (pile) {
                            console.log('æ‰¾åˆ°ç›®æ ‡æ¡©:', pile.id); // è°ƒè¯•æ—¥å¿—
                            targetPile = pile;
                            break;
                        }
                    }
                } catch (e) {
                    console.error('elementsFromPoint å‡ºé”™:', e);
                }
                
                // æ¢å¤æ‹–æ‹½å…ƒç´ æ˜¾ç¤º
                if (this.draggedCards) {
                    this.draggedCards.forEach((card, index) => {
                        card.style.display = originalDisplay[index] || '';
                    });
                }
                
                // å¦‚æœè¿˜æ²¡æ‰¾åˆ°ï¼Œæ‰‹åŠ¨æ£€æŸ¥è¾¹ç•Œ
                if (!targetPile) {
                    const piles = document.querySelectorAll('.tableau-pile');
                    console.log('æ‰‹åŠ¨æ£€æŸ¥', piles.length, 'ä¸ªæ¡©'); // è°ƒè¯•æ—¥å¿—
                    
                    for (const pile of piles) {
                        const rect = pile.getBoundingClientRect();
                        const margin = 50; // æ›´å¤§çš„æ£€æµ‹è¾¹è·
                        
                        if (x >= rect.left - margin && 
                            x <= rect.right + margin && 
                            y >= rect.top - margin && 
                            y <= rect.bottom + margin + 150) { // æ›´å¤§çš„åº•éƒ¨åŒºåŸŸ
                            console.log('è¾¹ç•Œæ£€æµ‹æ‰¾åˆ°ç›®æ ‡æ¡©:', pile.id); // è°ƒè¯•æ—¥å¿—
                            targetPile = pile;
                            break;
                        }
                    }
                }
                
                if (!targetPile) {
                    console.log('æ²¡æœ‰æ‰¾åˆ°ç›®æ ‡æ¡©'); // è°ƒè¯•æ—¥å¿—
                }
                
                return targetPile;
            }

            initializeEventListeners() {
                console.log('æ­£åœ¨åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨'); // è°ƒè¯•æ—¥å¿—
                
                // æ£€æŸ¥å…³é”®å…ƒç´ æ˜¯å¦å­˜åœ¨
                const startBtn = document.getElementById('start-game-btn');
                const backBtn = document.getElementById('back-to-landing');
                
                console.log('å¼€å§‹æŒ‰é’®:', startBtn ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
                console.log('è¿”å›æŒ‰é’®:', backBtn ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
                
                // Landing page to game transition
                if (startBtn) {
                    startBtn.addEventListener('click', () => {
                        console.log('å¼€å§‹æŒ‰é’®è¢«ç‚¹å‡»'); // è°ƒè¯•æ—¥å¿—
                        this.startGame();
                    });
                } else {
                    console.error('æ‰¾ä¸åˆ°å¼€å§‹æ¸¸æˆæŒ‰é’®');
                }

                if (backBtn) {
                    backBtn.addEventListener('click', () => {
                        this.backToLanding();
                    });
                }

                const backWinBtn = document.getElementById('back-to-home-win');
                if (backWinBtn) {
                    backWinBtn.addEventListener('click', () => {
                        this.backToLanding();
                    });
                }

                // Game controls - using event delegation to handle dynamic elements
                document.addEventListener('click', (e) => {
                    if (e.target.closest('#stock-pile')) {
                        console.log('åº“å­˜æ¡©è¢«ç‚¹å‡»'); // è°ƒè¯•æ—¥å¿—
                        this.dealCards();
                    } else if (e.target.closest('#restart-btn-top')) {
                        this.restartGame();
                    } else if (e.target.closest('#restart-btn-win')) {
                        this.restartGame();
                    } else if (e.target.closest('#hint-btn')) {
                        this.showHint();
                    }
                });

                // Drag events - using event delegation for dynamic card elements
                document.addEventListener('mousedown', (e) => this.handleStart(e));
                document.addEventListener('touchstart', (e) => this.handleStart(e), { passive: false });
                
                document.addEventListener('mousemove', (e) => this.handleMove(e));
                document.addEventListener('touchmove', (e) => this.handleMove(e), { passive: false });
                
                document.addEventListener('mouseup', (e) => this.handleEnd(e));
                document.addEventListener('touchend', (e) => this.handleEnd(e));

                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.isDragging) {
                        this.cancelDrag();
                    }
                });
                
                console.log('äº‹ä»¶ç›‘å¬å™¨è®¾ç½®å®Œæˆ'); // è°ƒè¯•æ—¥å¿—
            }

            startGame() {
                console.log('å¼€å§‹æ¸¸æˆ'); // è°ƒè¯•æ—¥å¿—
                document.body.classList.add('game-active');
                document.body.classList.add('fade-in');
                
                // ç¡®ä¿æ¸¸æˆçŠ¶æ€è¢«æ­£ç¡®åˆå§‹åŒ–
                this.initializeGame();
                
                // æ·»åŠ ä¸€ä¸ªå°å»¶è¿Ÿç¡®ä¿DOMæ›´æ–°å®Œæˆ
                setTimeout(() => {
                    console.log('æ¸¸æˆçŠ¶æ€:', this.gameState);
                    console.log('tableau piles:', this.gameState?.tableauPiles?.map(pile => pile.length));
                    this.renderGame();
                }, 100);
            }

            backToLanding() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                document.getElementById('fireworks').style.display = 'none';
                document.getElementById('win-message').style.display = 'none';
                document.body.classList.remove('game-active');
                this.gameState = null;
            }

            // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆå¡ç‰‡HTML
            generateCardHTML(card, isRed) {
                const suitSymbols = { 'spades': 'â™ ', 'hearts': 'â™¥', 'clubs': 'â™£', 'diamonds': 'â™¦' };
                
                const cardBack = `
                    <div class="card-face card-back">
                        <span class="text-white text-xs font-bold">IMP</span>
                    </div>
                `;
                
                const cardFront = `
                    <div class="card-face card-front ${isRed ? 'is-red' : ''}">
                        <span class="card-value self-start p-1">${card.name}</span>
                        <span class="suit-symbol">${suitSymbols[card.suit]}</span>
                        <span class="card-value self-end p-1 rotate-180">${card.name}</span>
                    </div>
                `;
                
                return cardBack + cardFront;
            }

            // å®Œå–„çš„æ‹–æ‹½å¼€å§‹å¤„ç†
            handleStart(e) {
                if (!document.body.classList.contains('game-active')) return;
                
                const cardElement = e.target.closest('.card-container');
                if (!cardElement || !cardElement.classList.contains('is-flipped')) {
                    return;
                }

                e.preventDefault();
                e.stopPropagation();
                
                console.log('å¼€å§‹æ‹–æ‹½ï¼Œå¡ç‰‡:', cardElement.dataset);
                
                this.originalPileIndex = parseInt(cardElement.dataset.pileIndex);
                this.originalCardIndex = parseInt(cardElement.dataset.cardIndex);
                
                if (isNaN(this.originalPileIndex) || isNaN(this.originalCardIndex)) {
                    console.error('æ— æ•ˆçš„æ¡©ç´¢å¼•æˆ–å¡ç‰‡ç´¢å¼•');
                    return;
                }
                
                const pile = this.gameState.tableauPiles[this.originalPileIndex];
                if (!pile || this.originalCardIndex >= pile.length) {
                    console.error('æ‰¾ä¸åˆ°å¯¹åº”çš„ç‰Œå †æˆ–å¡ç‰‡');
                    return;
                }
                
                // è·å–è¦æ‹–æ‹½çš„å¡ç‰‡æ•°æ®
                const cardsToCheck = pile.slice(this.originalCardIndex);
                
                // éªŒè¯æ‹–æ‹½åºåˆ—çš„æœ‰æ•ˆæ€§
                if (!this.isValidDragSequence(cardsToCheck)) {
                    console.log('æ— æ•ˆçš„æ‹–æ‹½åºåˆ—ï¼Œåªå…è®¸åŒèŠ±è‰²é€’å‡åºåˆ—');
                    return;
                }
                
                // è·å–å¯¹åº”çš„DOMå…ƒç´ 
                const allCardsInPile = Array.from(cardElement.parentElement.children);
                const cardsToDrag = allCardsInPile.slice(this.originalCardIndex);
                
                this.draggedCards = cardsToDrag;
                this.isDragging = true;
                
                console.log('å‡†å¤‡æ‹–æ‹½', cardsToDrag.length, 'å¼ ç‰Œï¼Œåºåˆ—æœ‰æ•ˆ');
                
                // ä¿å­˜åŸå§‹ä½ç½®ä¿¡æ¯
                this.originalPositions = this.draggedCards.map(card => ({
                    element: card,
                    top: card.style.top,
                    left: card.style.left || '0px',
                    position: card.style.position || 'absolute',
                    zIndex: card.style.zIndex || 'auto'
                }));
                
                // è®¾ç½®æ‹–æ‹½æ ·å¼
                this.draggedCards.forEach((card, index) => {
                    card.style.position = 'fixed';
                    card.style.zIndex = (1000 + index).toString();
                    card.style.pointerEvents = 'none';
                    card.style.cursor = 'grabbing';
                    card.classList.add('dragging');
                });
                
                // è®¡ç®—é¼ æ ‡åç§»
                const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
                const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
                
                const rect = cardElement.getBoundingClientRect();
                this.offsetX = clientX - rect.left;
                this.offsetY = clientY - rect.top;
                
                this.updateDragPosition(clientX, clientY);
                
                document.body.style.userSelect = 'none';
                document.body.style.cursor = 'grabbing';
            }

            handleMove(e) {
                if (!this.isDragging || !this.draggedCards || this.draggedCards.length === 0) return;
                
                e.preventDefault();
                e.stopPropagation();
                
                const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
                const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
                
                this.updateDragPosition(clientX, clientY);
                this.highlightDropTargets(clientX, clientY);
            }

            updateDragPosition(clientX, clientY) {
                if (!this.draggedCards || this.draggedCards.length === 0) return;
                
                this.draggedCards.forEach((card, index) => {
                    if (card && card.style) {
                        const newLeft = clientX - this.offsetX;
                        const newTop = clientY - this.offsetY + (index * 15);
                        
                        card.style.left = `${newLeft}px`;
                        card.style.top = `${newTop}px`;
                    }
                });
            }

            highlightDropTargets(clientX, clientY) {
                // ç§»é™¤ä¹‹å‰çš„é«˜äº®
                document.querySelectorAll('.tableau-pile.drag-over').forEach(pile => {
                    pile.classList.remove('drag-over');
                });
                
                // é«˜äº®å½“å‰æ‚¬åœçš„æ¡©
                const dropTarget = this.getDropTarget(clientX, clientY);
                if (dropTarget) {
                    const targetPileIndex = parseInt(dropTarget.id.replace('pile-', ''));
                    const draggedCardsData = this.gameState.tableauPiles[this.originalPileIndex]
                        .slice(this.originalCardIndex);
                    
                    // ç¡®ä¿ä¸æ˜¯åŒä¸€ä¸ªæ¡©ï¼Œå¹¶ä¸”ç§»åŠ¨æœ‰æ•ˆ
                    if (targetPileIndex !== this.originalPileIndex && 
                        this.isValidMove(draggedCardsData, targetPileIndex)) {
                        dropTarget.classList.add('drag-over');
                    }
                }
            }

            // å®Œå–„çš„æ‹–æ‹½ç»“æŸå¤„ç†
            handleEnd(e) {
                if (!this.isDragging || !this.draggedCards || this.draggedCards.length === 0) return;
                
                console.log('ç»“æŸæ‹–æ‹½');
                
                const clientX = e.clientX || (e.changedTouches && e.changedTouches[0] ? e.changedTouches[0].clientX : 0);
                const clientY = e.clientY || (e.changedTouches && e.changedTouches[0] ? e.changedTouches[0].clientY : 0);
                
                console.log('æ”¾ä¸‹ä½ç½®:', clientX, clientY);
                
                const dropTarget = this.getDropTarget(clientX, clientY);
                console.log('ç›®æ ‡æ¡©:', dropTarget ? dropTarget.id : 'æ— ');
                
                const cardsDataToMove = this.gameState.tableauPiles[this.originalPileIndex]
                    .slice(this.originalCardIndex);
                
                let moveSuccessful = false;
                
                if (dropTarget) {
                    const targetPileIndex = parseInt(dropTarget.id.replace('pile-', ''));
                    console.log('ç›®æ ‡æ¡©ç´¢å¼•:', targetPileIndex, 'åŸå§‹æ¡©ç´¢å¼•:', this.originalPileIndex);
                    
                    // éªŒè¯ç§»åŠ¨çš„æœ‰æ•ˆæ€§
                    if (targetPileIndex !== this.originalPileIndex && 
                        this.isValidMove(cardsDataToMove, targetPileIndex)) {
                        console.log('æ‰§è¡Œç§»åŠ¨');
                        this.performMove(targetPileIndex, cardsDataToMove);
                        moveSuccessful = true;
                    } else {
                        console.log('ç§»åŠ¨æ— æ•ˆ:', {
                            samepile: targetPileIndex === this.originalPileIndex,
                            validMove: this.isValidMove(cardsDataToMove, targetPileIndex),
                            targetPile: this.gameState.tableauPiles[targetPileIndex],
                            draggedCards: cardsDataToMove.map(c => `${c.name}${c.suit}`)
                        });
                    }
                } else {
                    console.log('æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„ç›®æ ‡æ¡©');
                }
                
                if (!moveSuccessful) {
                    console.log('è¿”å›åŸä½ç½®');
                    this.returnCardsToOriginalPosition();
                }
                
                this.cleanupDrag();
            }

            performMove(targetPileIndex, cardsDataToMove) {
                // æ‰§è¡Œå®é™…çš„æ•°æ®ç§»åŠ¨
                this.gameState.tableauPiles[this.originalPileIndex].splice(this.originalCardIndex);
                this.gameState.tableauPiles[targetPileIndex].push(...cardsDataToMove);
                
                // ç¿»å¼€æºæ¡©çš„æ–°é¡¶ç‰Œ
                const sourcePile = this.gameState.tableauPiles[this.originalPileIndex];
                if (sourcePile.length > 0) {
                    const newTopCard = sourcePile[sourcePile.length - 1];
                    if (!newTopCard.isFaceUp) {
                        newTopCard.isFaceUp = true;
                        this.gameState.score += 5;
                    }
                }
                
                this.gameState.moves++;
                
                // æ£€æŸ¥å®Œæ•´åºåˆ—
                const targetPile = this.gameState.tableauPiles[targetPileIndex];
                if (this.checkCompleteSequence(targetPile)) {
                    const completedSequence = targetPile.splice(targetPile.length - 13, 13);
                    this.gameState.foundations.push(completedSequence);
                    this.gameState.score += 100;
                    this.gameState.completedSequences++;
                    
                    // ç¿»å¼€ç§»é™¤åºåˆ—åçš„æ–°é¡¶ç‰Œ
                    if (targetPile.length > 0) {
                        const newTopCard = targetPile[targetPile.length - 1];
                        if (!newTopCard.isFaceUp) {
                            newTopCard.isFaceUp = true;
                            this.gameState.score += 5;
                        }
                    }
                    
                    this.checkWinState();
                }
                
                // é‡æ–°æ¸²æŸ“æ¸¸æˆ
                this.renderGame();
            }

            returnCardsToOriginalPosition() {
                if (!this.originalPositions || this.originalPositions.length === 0) return;
                
                this.originalPositions.forEach((pos, index) => {
                    const element = pos.element;
                    element.style.transition = 'all 0.3s ease';
                    element.style.position = 'absolute';
                    element.style.top = pos.top;
                    element.style.left = pos.left || '0px';
                    element.style.zIndex = pos.zIndex || 'auto';
                });
                
                // æ¸…ç†è¿‡æ¸¡æ•ˆæœ
                setTimeout(() => {
                    this.originalPositions.forEach(pos => {
                        pos.element.style.transition = '';
                    });
                    this.renderGame();
                }, 300);
            }

            cancelDrag() {
                if (this.isDragging) {
                    this.returnCardsToOriginalPosition();
                    this.cleanupDrag();
                }
            }

            cleanupDrag() {
                console.log('æ¸…ç†æ‹–æ‹½çŠ¶æ€'); // è°ƒè¯•æ—¥å¿—
                
                // ç§»é™¤é«˜äº®
                document.querySelectorAll('.tableau-pile.drag-over').forEach(pile => {
                    pile.classList.remove('drag-over');
                });
                
                // é‡ç½®æ‹–æ‹½çŠ¶æ€
                if (this.draggedCards && this.draggedCards.length > 0) {
                    this.draggedCards.forEach(card => {
                        if (card && card.classList) {
                            card.classList.remove('dragging');
                            card.style.pointerEvents = '';
                            card.style.cursor = '';
                        }
                    });
                }
                
                // é‡ç½®å…¨å±€çŠ¶æ€
                this.draggedCards = null;
                this.isDragging = false;
                this.originalPositions = [];
                this.originalPileIndex = null;
                this.originalCardIndex = null;
                this.offsetX = 0;
                this.offsetY = 0;
                
                // æ¢å¤é¡µé¢æ ·å¼
                document.body.style.userSelect = '';
                document.body.style.cursor = '';
            }

            showHint() {
                const hints = [];
                
                for (let pileIndex = 0; pileIndex < 10; pileIndex++) {
                    const pile = this.gameState.tableauPiles[pileIndex];
                    if (pile.length === 0) continue;
                    
                    const topCard = pile[pile.length - 1];
                    if (!topCard.isFaceUp) continue;
                    
                    for (let targetIndex = 0; targetIndex < 10; targetIndex++) {
                        if (targetIndex === pileIndex) continue;
                        
                        if (this.isValidMove([topCard], targetIndex)) {
                            hints.push(`å¯ä»¥å°† ${topCard.name}${this.getSuitSymbol(topCard.suit)} ä»ç¬¬${pileIndex + 1}æ¡©ç§»åŠ¨åˆ°ç¬¬${targetIndex + 1}æ¡©`);
                        }
                    }
                }
                
                if (hints.length > 0) {
                    alert(hints[0]);
                } else {
                    alert("æ²¡æœ‰æ‰¾åˆ°å¯è¡Œçš„ç§»åŠ¨ï¼Œå°è¯•å‘ç‰Œæˆ–é‡æ–°æ’åˆ—");
                }
            }

            getSuitSymbol(suit) {
                const symbols = { 'spades': 'â™ ', 'hearts': 'â™¥', 'clubs': 'â™£', 'diamonds': 'â™¦' };
                return symbols[suit] || suit;
            }

            winGame() {
                clearInterval(this.timerInterval);
                
                const timeBonus = Math.max(0, 1000 - Math.floor((Date.now() - this.startTime) / 1000));
                const finalScore = this.gameState.score + timeBonus;
                
                const elapsedTime = Date.now() - this.startTime;
                const minutes = Math.floor(elapsedTime / 60000);
                const seconds = Math.floor((elapsedTime % 60000) / 1000);
                const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                
                document.getElementById('final-time').textContent = formattedTime;
                document.getElementById('final-moves').textContent = this.gameState.moves;
                document.getElementById('final-score').textContent = finalScore;
                
                document.getElementById('fireworks').style.display = 'block';
                document.getElementById('win-message').style.display = 'block';
                
                this.startFireworks();
            }

            startFireworks() {
                const canvas = document.getElementById('fireworks');
                const ctx = canvas.getContext('2d');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                let particles = [];
                let animationId;
                
                const random = (min, max) => Math.random() * (max - min) + min;
                
                const createFirework = () => {
                    const x = random(100, canvas.width - 100);
                    const y = random(50, canvas.height / 2);
                    const colors = ['#30D158', '#0A84FF', '#AF52DE', '#FF9500', '#FF3B30', '#64D2FF'];
                    
                    for (let i = 0; i < 30; i++) {
                        particles.push({
                            x: x,
                            y: y,
                            vx: random(-6, 6),
                            vy: random(-6, 6),
                            life: 60,
                            maxLife: 60,
                            color: colors[Math.floor(Math.random() * colors.length)],
                            size: random(2, 4)
                        });
                    }
                };
                
                const animate = () => {
                    ctx.fillStyle = 'rgba(28, 28, 30, 0.1)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    particles.forEach((particle, index) => {
                        particle.x += particle.vx;
                        particle.y += particle.vy;
                        particle.vy += 0.15;
                        particle.life--;
                        
                        const alpha = particle.life / particle.maxLife;
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = particle.color;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * alpha, 0, Math.PI * 2);
                        ctx.fill();
                        
                        if (particle.life <= 0) {
                            particles.splice(index, 1);
                        }
                    });
                    
                    if (Math.random() < 0.04) {
                        createFirework();
                    }
                    
                    ctx.globalAlpha = 1;
                    animationId = requestAnimationFrame(animate);
                };
                
                animate();
                
                setTimeout(() => {
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                    }
                }, 8000);
            }

            restartGame() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                }
                
                document.getElementById('fireworks').style.display = 'none';
                document.getElementById('win-message').style.display = 'none';
                
                this.initializeGame();
            }
        }

        // Initialize the game
        console.log('å‡†å¤‡åˆå§‹åŒ–SpiderSolitaireå®ä¾‹'); // è°ƒè¯•æ—¥å¿—
        const game = new SpiderSolitaire();
        console.log('SpiderSolitaireå®ä¾‹åˆ›å»ºå®Œæˆ'); // è°ƒè¯•æ—¥å¿—
        
        // ç¡®ä¿åœ¨å¼€å§‹æ¸¸æˆæ—¶æ­£ç¡®åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMåŠ è½½å®Œæˆï¼Œæ¸¸æˆå‡†å¤‡å°±ç»ª');
            
            // æ£€æŸ¥å…³é”®DOMå…ƒç´ 
            const gameBoard = document.getElementById('game-board');
            const stockPile = document.getElementById('stock-pile');
            const startBtn = document.getElementById('start-game-btn');
            
            console.log('æ¸¸æˆé¢æ¿:', gameBoard ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
            console.log('åº“å­˜æ¡©:', stockPile ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
            console.log('å¼€å§‹æŒ‰é’®:', startBtn ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
            
            // æ£€æŸ¥tableauæ¡©
            for (let i = 0; i < 10; i++) {
                const pile = document.getElementById(`pile-${i}`);
                console.log(`æ¡© ${i}:`, pile ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
            }
        });
        
        // Prevent memory leaks on page unload
        window.addEventListener('beforeunload', () => {
            if (game.timerInterval) {
                clearInterval(game.timerInterval);
            }
            if (game.animationFrameId) {
                cancelAnimationFrame(game.animationFrameId);
            }
        });
    </script>
</body>
</html>

