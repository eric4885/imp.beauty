<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    
    <title>Imp Beauty - The Ultimate Imp Spider Solitaire Game</title>
    <meta name="description" content="Play Imp Beauty, a modern and elegant spider solitaire game. Enjoy a minimalist design with smooth gameplay on both desktop and mobile devices.">
    <link rel="canonical" href="https://imp.beauty/">

    <meta property="og:title" content="Imp Beauty - The Ultimate Imp Spider Solitaire Game">
    <meta property="og:description" content="Play Imp Beauty, a modern and elegant spider solitaire game. Enjoy a minimalist design with smooth gameplay on both desktop and mobile devices.">
    <meta property="og:url" content="https://imp.beauty/">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://imp.beauty/social-share-image.jpg">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Apple-inspired colors */
        :root {
            --color-dark-bg: #1C1C1E;
            --color-light-text: #F2F2F7;
            --color-accent-blue: #0A84FF;
            --color-accent-green: #30D158;
            --color-card-bg: #2C2C2E;
            --color-accent-purple: #AF52DE;
            --color-accent-orange: #FF9500;
            
            /* Game-specific variables */
            --card-width: 70px;
            --card-height: calc(var(--card-width) * 1.4);
            --card-radius: 8px;
            --card-bg-light: #F9FAFB;
            --card-bg-dark: var(--color-card-bg);
            --card-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            --red-suit: #FF3B30;
            --black-suit: #1C1C1E;
        }

        body {
            background-color: var(--color-dark-bg);
            color: var(--color-light-text);
            touch-action: manipulation;
        }

        /* Game state transitions */
        .landing-state {
            display: block;
        }
        .game-state {
            display: none;
        }
        
        .game-active .landing-state {
            display: none;
        }
        .game-active .game-state {
            display: block;
        }

        /* Hero section animations */
        .hero-title {
            background: linear-gradient(135deg, var(--color-accent-green), var(--color-accent-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { filter: brightness(1); }
            to { filter: brightness(1.2); }
        }

        .play-button {
            background: linear-gradient(135deg, var(--color-accent-green), var(--color-accent-blue));
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 10px 25px rgba(48, 209, 88, 0.3);
        }

        .play-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 20px 40px rgba(48, 209, 88, 0.4);
        }

        /* Card game styles */
        .card-container {
            width: var(--card-width);
            height: var(--card-height);
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            cursor: pointer;
            perspective: 1000px;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .card-container.transitioning {
            transition: transform 0.6s, top 0.3s ease, left 0.3s ease;
        }

        .card-container.dragging {
            z-index: 1000 !important;
            pointer-events: none;
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: var(--card-radius);
            box-shadow: var(--card-shadow);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }

        .card-front {
            background-color: var(--card-bg-light);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: var(--black-suit);
        }
        .card-front.is-red {
            color: var(--red-suit);
        }
        .card-front .card-value {
            font-size: 1.2rem;
            font-weight: bold;
            line-height: 1;
        }
        .card-front .suit-symbol {
             font-size: 1.5rem;
        }

        .card-back {
            background: linear-gradient(135deg, var(--color-card-bg), #3A3A3C);
            transform: rotateY(180deg);
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card-container.is-flipped {
            transform: rotateY(180deg);
        }

        .tableau-pile {
            position: relative;
            padding-top: 15px;
            min-height: calc(var(--card-height) + 80px);
            border: 2px dashed transparent;
            border-radius: var(--card-radius);
            transition: border-color 0.2s;
        }

        .tableau-pile.drag-over {
            border-color: var(--color-accent-blue);
            background-color: rgba(10, 132, 255, 0.1);
        }

        .tableau-pile .card-container {
            position: absolute;
            top: 0;
            left: 0;
            transition: top 0.3s ease;
        }

        #stock-pile {
            width: var(--card-width);
            height: var(--card-height);
            position: relative;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        #stock-pile:hover {
            transform: scale(1.05);
        }

        #stock-pile .card-back {
            position: absolute;
            top: 0;
            left: 0;
        }

        #foundations {
            display: flex;
            gap: 8px;
        }
        .foundation-pile {
             width: var(--card-width);
             height: var(--card-height);
             border: 2px solid rgba(255, 255, 255, 0.3);
             border-radius: var(--card-radius);
             display: flex;
             align-items: center;
             justify-content: center;
        }
        .foundation-pile .card-container {
            position: relative;
        }

        .foundation-pile.empty {
            background-color: rgba(255, 255, 255, 0.05);
        }

        #game-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            color: var(--color-light-text);
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }

        #fireworks {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
            z-index: 9999;
        }
        
        #win-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 0 0 10px black;
            display: none;
            text-align: center;
            z-index: 10000;
            background: linear-gradient(135deg, rgba(48, 209, 88, 0.9), rgba(10, 132, 255, 0.9));
            padding: 2rem;
            border-radius: 20px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn {
            background: var(--color-accent-blue);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border: none;
            color: white;
            font-weight: 500;
        }
        .btn:hover { 
            background: #0056CC;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(10, 132, 255, 0.3);
        }
        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            :root {
                --card-width: 60px;
            }
            .card-front .card-value {
                font-size: 1rem;
            }
            .card-front .suit-symbol {
                font-size: 1.2rem;
            }
            .hero-title {
                font-size: 3rem !important;
            }
        }

        /* Animations */
        @media (prefers-reduced-motion: reduce) {
            .card-container {
                transition: none;
            }
        }

        .fade-in {
            animation: fadeIn 0.6s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: var(--color-dark-bg);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--color-accent-blue);
            border-radius: 4px;
        }
    </style>
</head>
<body class="font-sans antialiased text-white">

    <!-- Landing Page State -->
    <div class="landing-state">
        <div class="min-h-screen flex flex-col items-center justify-center p-4">
            <header class="text-center mb-8">
                <h1 class="hero-title text-6xl md:text-8xl font-bold tracking-tight">Imp Beauty</h1>
                <p class="mt-4 text-lg md:text-xl font-light text-gray-400">The most elegant spider solitaire game you'll ever play.</p>
            </header>

            <main class="w-full max-w-2xl text-center">
                <p class="text-xl md:text-2xl font-medium leading-relaxed mb-8">
                    Unwind with <span style="color: var(--color-accent-blue);" class="font-bold">Imp Beauty</span>, a beautifully designed spider solitaire experience. With a minimalist interface and fluid animations, it's the perfect way to pass the time.
                </p>

                <div class="mb-8">
                    <button id="start-game-btn" class="play-button text-white text-xl font-bold py-4 px-8 rounded-2xl">
                        🎴 Start Playing
                    </button>
                </div>

                <div id="game-preview" class="w-full bg-gray-800 rounded-2xl shadow-xl border-4 mb-12" style="border-color: var(--color-card-bg);">
                    <div class="h-96 md:h-[500px] flex items-center justify-center text-xl font-semibold text-gray-400 p-8">
                        <div class="text-center">
                            <div class="text-6xl mb-4">🎴</div>
                            <div class="text-lg">Click "Start Playing" to begin your adventure</div>
                            <div class="text-sm text-gray-500 mt-2">No registration required • Play instantly</div>
                        </div>
                    </div>
                </div>

                <div class="text-left space-y-6">
                    <h2 class="text-3xl font-bold" style="color: var(--color-accent-blue);">Game Overview</h2>
                    <p class="text-base leading-relaxed text-gray-400">
                        <strong class="text-white">Imp Beauty</strong> is a modern take on the classic spider solitaire game. The goal is to create sets of cards from King to Ace, which are then removed from the tableau. The game is designed for a seamless experience on any device, from a large desktop monitor to a smartphone.
                    </p>
                    <ul class="list-disc list-inside space-y-2 text-base text-gray-400">
                        <li><strong class="text-white">Fluid Gameplay:</strong> Drag and drop cards with smooth, intuitive controls.</li>
                        <li><strong class="text-white">Minimalist Design:</strong> A clean interface that lets you focus on the game, not the clutter.</li>
                        <li><strong class="text-white">Adaptive Display:</strong> Automatically adjusts to your screen size for optimal play.</li>
                        <li><strong class="text-white">Offline Mode:</strong> Play anytime, anywhere, with no internet required.</li>
                        <li><strong class="text-white">Score System:</strong> Challenge yourself with our intelligent scoring system.</li>
                        <li><strong class="text-white">Hint System:</strong> Get helpful suggestions when you're stuck.</li>
                    </ul>
                </div>
            </main>

            <footer class="mt-12 text-center text-sm font-light text-gray-500">
                <p>&copy; 2025 Imp.Beauty. All rights reserved.</p>
            </footer>
        </div>
    </div>

    <!-- Game State -->
    <div class="game-state">
        <div class="p-4 md:p-6 max-w-7xl mx-auto">
            <!-- Game Header -->
            <div class="text-center mb-6">
                <h1 class="text-2xl md:text-3xl font-bold" style="color: var(--color-accent-green);">Imp Beauty</h1>
                <button id="back-to-landing" class="mt-2 text-sm text-gray-400 hover:text-white transition-colors">← Back to Home</button>
            </div>

            <!-- Game Stats -->
            <div id="game-stats" class="flex justify-between items-center mb-4 text-sm">
                <div class="flex gap-4">
                    <span id="moves-counter">步数: 0</span>
                    <span id="timer-counter">时间: 00:00</span>
                    <span id="score-counter">得分: 0</span>
                </div>
                <div class="flex gap-2">
                    <button id="hint-btn" class="btn btn-secondary">💡 提示</button>
                    <button id="restart-btn-top" class="btn">🔄 重新开始</button>
                </div>
            </div>
            
            <!-- Stock and Foundations -->
            <div class="flex justify-between items-start mb-4">
                <div class="flex flex-col items-center">
                    <div id="stock-pile">
                        <div class="card-face card-back">
                             <span class="text-white text-sm font-bold">IMP</span>
                        </div>
                    </div>
                    <div class="text-center text-xs text-gray-400 mt-1">
                        剩余: <span id="stock-count">50</span>
                    </div>
                </div>
                
                <div id="foundations" class="flex flex-wrap justify-end gap-1">
                    <!-- Foundation piles will be rendered here -->
                </div>
            </div>

            <!-- Game Board -->
            <div id="game-board" class="grid grid-cols-5 md:grid-cols-10 gap-1 md:gap-2">
                <div id="pile-0" class="tableau-pile"></div>
                <div id="pile-1" class="tableau-pile"></div>
                <div id="pile-2" class="tableau-pile"></div>
                <div id="pile-3" class="tableau-pile"></div>
                <div id="pile-4" class="tableau-pile"></div>
                <div id="pile-5" class="tableau-pile"></div>
                <div id="pile-6" class="tableau-pile"></div>
                <div id="pile-7" class="tableau-pile"></div>
                <div id="pile-8" class="tableau-pile"></div>
                <div id="pile-9" class="tableau-pile"></div>
            </div>
        </div>
    </div>
    
    <!-- Game Win Elements -->
    <canvas id="fireworks"></canvas>
    <div id="win-message">
        🎉 恭喜获胜！ 🎉<br>
        <div class="mt-4 text-base font-normal">
            完成时间: <span id="final-time"></span><br>
            总步数: <span id="final-moves"></span><br>
            最终得分: <span id="final-score"></span>
        </div>
        <div class="mt-6 flex gap-3 justify-center">
            <button id="restart-btn-win" class="btn">🎮 再玩一局</button>
            <button id="back-to-home-win" class="btn btn-secondary">🏠 返回首页</button>
        </div>
    </div>

    <script>
        class Card {
            constructor(suit, value, name) {
                this.suit = suit;
                this.value = value;
                this.name = name;
                this.isFaceUp = false;
                this.id = `${suit}_${value}_${Math.random().toString(36).substr(2, 9)}`;
            }
        }

        class SpiderSolitaire {
            constructor() {
                this.gameState = null;
                this.timerInterval = null;
                this.startTime = null;
                this.draggedCards = null;
                this.originalPileIndex = null;
                this.originalCardIndex = null;
                this.originalPositions = [];
                this.isDragging = false;
                this.animationFrameId = null;
                
                this.initializeEventListeners();
            }

            createAndShuffleDeck() {
                const suits = ['spades', 'hearts', 'clubs', 'diamonds'];
                const values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];
                const cardNames = {
                    1: 'A', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7',
                    8: '8', 9: '9', 10: '10', 11: 'J', 12: 'Q', 13: 'K'
                };

                let deck = [];
                for (let i = 0; i < 2; i++) {
                    for (const suit of suits) {
                        for (const value of values) {
                            deck.push(new Card(suit, value, cardNames[value]));
                        }
                    }
                }
                
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
                
                return deck;
            }

            initializeGame(shuffledDeck = null) {
                if (!shuffledDeck) {
                    shuffledDeck = this.createAndShuffleDeck();
                }

                this.gameState = {
                    tableauPiles: Array.from({ length: 10 }, () => []),
                    stockPiles: [],
                    foundations: [],
                    moves: 0,
                    score: 500,
                    completedSequences: 0
                };

                let cardIndex = 0;
                const cardsPerPile = [6, 6, 6, 6, 5, 5, 5, 5, 5, 5];

                for (let pileIndex = 0; pileIndex < 10; pileIndex++) {
                    for (let i = 0; i < cardsPerPile[pileIndex]; i++) {
                        let card = shuffledDeck[cardIndex];
                        this.gameState.tableauPiles[pileIndex].push(card);
                        cardIndex++;
                    }
                    let topCard = this.gameState.tableauPiles[pileIndex][this.gameState.tableauPiles[pileIndex].length - 1];
                    if (topCard) {
                        topCard.isFaceUp = true;
                    }
                }
                
                this.gameState.stockPiles = shuffledDeck.slice(cardIndex);
                
                this.startTimer();
                this.renderGame();
            }

            startTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                this.startTime = Date.now();
                this.timerInterval = setInterval(() => this.updateTimer(), 1000);
            }

            updateTimer() {
                if (!this.startTime) return;
                
                const elapsedTime = Date.now() - this.startTime;
                const minutes = Math.floor(elapsedTime / 60000);
                const seconds = Math.floor((elapsedTime % 60000) / 1000);
                
                const formattedMinutes = String(minutes).padStart(2, '0');
                const formattedSeconds = String(seconds).padStart(2, '0');
                
                document.getElementById('timer-counter').textContent = `时间: ${formattedMinutes}:${formattedSeconds}`;
            }

            renderGame() {
                if (!this.gameState) return;

                this.updateGameStats();
                this.renderStockPile();
                this.renderFoundations();
                this.renderTableauPiles();
            }

            updateGameStats() {
                document.getElementById('moves-counter').textContent = `步数: ${this.gameState.moves}`;
                document.getElementById('score-counter').textContent = `得分: ${this.gameState.score}`;
                document.getElementById('stock-count').textContent = this.gameState.stockPiles.length;
            }

            renderStockPile() {
                const stockPileElement = document.getElementById('stock-pile');
                if (this.gameState.stockPiles.length > 0) {
                    stockPileElement.style.opacity = '1';
                    stockPileElement.style.cursor = 'pointer';
                } else {
                    stockPileElement.style.opacity = '0.5';
                    stockPileElement.style.cursor = 'not-allowed';
                }
            }

            renderFoundations() {
                const foundationsElement = document.getElementById('foundations');
                foundationsElement.innerHTML = '';
                
                this.gameState.foundations.forEach((foundationPile, index) => {
                    const foundationContainer = document.createElement('div');
                    foundationContainer.className = 'foundation-pile';
                    
                    if (foundationPile.length > 0) {
                        const topCard = foundationPile[foundationPile.length - 1];
                        const isRed = topCard.suit === 'hearts' || topCard.suit === 'diamonds';
                        const suitSymbols = { 'spades': '♠', 'hearts': '♥', 'clubs': '♣', 'diamonds': '♦' };
                        
                        foundationContainer.innerHTML = `
                            <div class="card-container is-flipped">
                                <div class="card-face card-back"></div>
                                <div class="card-face card-front ${isRed ? 'is-red' : ''}">
                                    <span class="card-value self-start p-1">${topCard.name}</span>
                                    <span class="suit-symbol">${suitSymbols[topCard.suit]}</span>
                                    <span class="card-value self-end p-1 rotate-180">${topCard.name}</span>
                                </div>
                            </div>
                        `;
                    } else {
                        foundationContainer.classList.add('empty');
                        foundationContainer.innerHTML = '<span class="text-gray-500 text-xs">完成桩</span>';
                    }
                    
                    foundationsElement.appendChild(foundationContainer);
                });
            }

            renderTableauPiles() {
                const suitSymbols = { 'spades': '♠', 'hearts': '♥', 'clubs': '♣', 'diamonds': '♦' };
                
                this.gameState.tableauPiles.forEach((pile, pileIndex) => {
                    const pileElement = document.getElementById(`pile-${pileIndex}`);
                    pileElement.innerHTML = '';
                    
                    pile.forEach((card, cardIndex) => {
                        const cardContainer = document.createElement('div');
                        cardContainer.className = 'card-container';
                        cardContainer.dataset.cardIndex = cardIndex;
                        cardContainer.dataset.pileIndex = pileIndex;
                        cardContainer.dataset.cardId = card.id;
                        
                        const topOffset = cardIndex * 15;
                        cardContainer.style.top = `${topOffset}px`;
                        
                        const isRed = card.suit === 'hearts' || card.suit === 'diamonds';
                        
                        const cardBack = document.createElement('div');
                        cardBack.className = 'card-face card-back';
                        cardBack.innerHTML = '<span class="text-white text-xs font-bold">IMP</span>';

                        const cardFront = document.createElement('div');
                        cardFront.className = `card-face card-front ${isRed ? 'is-red' : ''}`;
                        cardFront.innerHTML = `
                            <span class="card-value self-start p-1">${card.name}</span>
                            <span class="suit-symbol">${suitSymbols[card.suit]}</span>
                            <span class="card-value self-end p-1 rotate-180">${card.name}</span>
                        `;

                        cardContainer.appendChild(cardBack);
                        cardContainer.appendChild(cardFront);

                        if (card.isFaceUp) {
                            cardContainer.classList.add('is-flipped');
                            cardContainer.style.cursor = 'grab';
                            // Add draggable attribute for better UX
                            cardContainer.setAttribute('draggable', 'false');
                        } else {
                            cardContainer.style.cursor = 'default';
                        }

                        pileElement.appendChild(cardContainer);
                    });
                });
            }

            checkCompleteSequence(pile) {
                if (pile.length < 13) return false;
                
                const sequence = pile.slice(-13);
                const topCard = sequence[12];
                
                if (topCard.value !== 1) return false;
                
                for (let i = 0; i < 12; i++) {
                    const currentCard = sequence[i];
                    const nextCard = sequence[i + 1];
                    
                    if (currentCard.value !== nextCard.value + 1 || 
                        currentCard.suit !== nextCard.suit) {
                        return false;
                    }
                }
                
                return true;
            }

            checkWinState() {
                let totalFoundationCards = 0;
                this.gameState.foundations.forEach(pile => {
                    totalFoundationCards += pile.length;
                });

                if (totalFoundationCards === 104) {
                    this.winGame();
                }
            }

            dealCards() {
                if (this.gameState.stockPiles.length === 0) {
                    console.log("库存牌已用完");
                    return;
                }

                for (let i = 0; i < 10; i++) {
                    if (this.gameState.tableauPiles[i].length === 0) {
                        alert("有空桩时无法发牌，请先移动牌到空桩");
                        return;
                    }
                }

                for (let i = 0; i < 10; i++) {
                    if (this.gameState.stockPiles.length > 0) {
                        const cardToDeal = this.gameState.stockPiles.shift();
                        cardToDeal.isFaceUp = true;
                        this.gameState.tableauPiles[i].push(cardToDeal);
                    }
                }
                
                this.gameState.moves++;
                this.gameState.score -= 1;
                this.renderGame();
                this.checkForAutoFlips();
            }

            checkForAutoFlips() {
                let hasFlipped = false;
                this.gameState.tableauPiles.forEach(pile => {
                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        if (!topCard.isFaceUp) {
                            topCard.isFaceUp = true;
                            hasFlipped = true;
                        }
                    }
                });
                
                if (hasFlipped) {
                    setTimeout(() => this.renderGame(), 100);
                }
            }

            isValidMove(draggedCardsData, targetPileIndex) {
                if (!draggedCardsData || draggedCardsData.length === 0) return false;
                
                const targetPile = this.gameState.tableauPiles[targetPileIndex];
                const firstDraggedCard = draggedCardsData[0];
                
                if (targetPile.length === 0) {
                    return true;
                }

                const topCardOfTargetPile = targetPile[targetPile.length - 1];
                return firstDraggedCard.value === topCardOfTargetPile.value - 1;
            }

            isValidDragSequence(cards) {
                if (cards.length === 1) return true;
                
                for (let i = 0; i < cards.length - 1; i++) {
                    const currentCard = cards[i];
                    const nextCard = cards[i + 1];
                    
                    if (currentCard.value !== nextCard.value + 1 || 
                        currentCard.suit !== nextCard.suit) {
                        return false;
                    }
                }
                return true;
            }

            getDropTarget(x, y) {
                const elements = document.elementsFromPoint(x, y);
                for (const element of elements) {
                    const pile = element.closest('.tableau-pile');
                    if (pile) {
                        return pile;
                    }
                }
                return null;
            }

            initializeEventListeners() {
                // Landing page to game transition
                document.getElementById('start-game-btn').addEventListener('click', () => {
                    this.startGame();
                });

                document.getElementById('back-to-landing').addEventListener('click', () => {
                    this.backToLanding();
                });

                document.getElementById('back-to-home-win').addEventListener('click', () => {
                    this.backToLanding();
                });

                // Game controls - using event delegation to handle dynamic elements
                document.addEventListener('click', (e) => {
                    if (e.target.closest('#stock-pile')) {
                        this.dealCards();
                    } else if (e.target.closest('#restart-btn-top')) {
                        this.restartGame();
                    } else if (e.target.closest('#restart-btn-win')) {
                        this.restartGame();
                    } else if (e.target.closest('#hint-btn')) {
                        this.showHint();
                    }
                });

                // Drag events - using event delegation for dynamic card elements
                document.addEventListener('mousedown', (e) => this.handleStart(e));
                document.addEventListener('touchstart', (e) => this.handleStart(e), { passive: false });
                
                document.addEventListener('mousemove', (e) => this.handleMove(e));
                document.addEventListener('touchmove', (e) => this.handleMove(e), { passive: false });
                
                document.addEventListener('mouseup', (e) => this.handleEnd(e));
                document.addEventListener('touchend', (e) => this.handleEnd(e));

                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.isDragging) {
                        this.cancelDrag();
                    }
                });
            }

            startGame() {
                document.body.classList.add('game-active');
                document.body.classList.add('fade-in');
                this.initializeGame();
            }

            backToLanding() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                document.getElementById('fireworks').style.display = 'none';
                document.getElementById('win-message').style.display = 'none';
                document.body.classList.remove('game-active');
                this.gameState = null;
            }

            handleStart(e) {
                // Only handle drag events when in game mode and targeting cards
                if (!document.body.classList.contains('game-active')) return;
                
                const cardElement = e.target.closest('.card-container');
                if (!cardElement || !cardElement.classList.contains('is-flipped')) {
                    return;
                }

                // Prevent default behavior for dragging
                e.preventDefault();
                e.stopPropagation();
                
                this.originalPileIndex = parseInt(cardElement.dataset.pileIndex);
                this.originalCardIndex = parseInt(cardElement.dataset.cardIndex);
                
                const pile = this.gameState.tableauPiles[this.originalPileIndex];
                const cardsToCheck = pile.slice(this.originalCardIndex);
                
                if (!this.isValidDragSequence(cardsToCheck)) {
                    if (cardsToCheck.length > 1) {
                        return;
                    }
                }
                
                const cardElements = Array.from(cardElement.parentElement.children)
                    .slice(this.originalCardIndex);
                
                this.draggedCards = cardElements;
                this.isDragging = true;
                
                this.originalPositions = this.draggedCards.map(card => ({
                    element: card,
                    top: card.style.top,
                    left: card.style.left,
                    position: card.style.position,
                    zIndex: card.style.zIndex
                }));
                
                this.draggedCards.forEach((card, index) => {
                    card.classList.add('dragging');
                    card.style.position = 'fixed';
                    card.style.zIndex = 1000 + index;
                    card.style.pointerEvents = 'none';
                    card.style.cursor = 'grabbing';
                });
                
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                
                const rect = cardElement.getBoundingClientRect();
                this.offsetX = clientX - rect.left;
                this.offsetY = clientY - rect.top;
                
                this.updateDragPosition(clientX, clientY);
                
                document.body.style.userSelect = 'none';
            }

            handleMove(e) {
                if (!this.isDragging || !this.draggedCards) return;
                
                e.preventDefault();
                
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                
                this.updateDragPosition(clientX, clientY);
                this.highlightDropTargets(clientX, clientY);
            }

            updateDragPosition(clientX, clientY) {
                if (!this.draggedCards) return;
                
                this.draggedCards.forEach((card, index) => {
                    card.style.left = `${clientX - this.offsetX}px`;
                    card.style.top = `${clientY - this.offsetY + (index * 15)}px`;
                });
            }

            highlightDropTargets(clientX, clientY) {
                document.querySelectorAll('.tableau-pile.drag-over').forEach(pile => {
                    pile.classList.remove('drag-over');
                });
                
                const dropTarget = this.getDropTarget(clientX, clientY);
                if (dropTarget) {
                    const targetPileIndex = parseInt(dropTarget.id.replace('pile-', ''));
                    const draggedCardsData = this.gameState.tableauPiles[this.originalPileIndex]
                        .slice(this.originalCardIndex);
                    
                    if (this.isValidMove(draggedCardsData, targetPileIndex)) {
                        dropTarget.classList.add('drag-over');
                    }
                }
            }

            handleEnd(e) {
                if (!this.isDragging || !this.draggedCards) return;
                
                const clientX = e.clientX || e.changedTouches?.[0]?.clientX || e.clientX;
                const clientY = e.clientY || e.changedTouches?.[0]?.clientY || e.clientY;
                
                const dropTarget = this.getDropTarget(clientX, clientY);
                const cardsDataToMove = this.gameState.tableauPiles[this.originalPileIndex]
                    .slice(this.originalCardIndex);
                
                let moveSuccessful = false;
                
                if (dropTarget) {
                    const targetPileIndex = parseInt(dropTarget.id.replace('pile-', ''));
                    
                    if (this.isValidMove(cardsDataToMove, targetPileIndex)) {
                        this.performMove(targetPileIndex, cardsDataToMove);
                        moveSuccessful = true;
                    }
                }
                
                if (!moveSuccessful) {
                    this.returnCardsToOriginalPosition();
                }
                
                this.cleanupDrag();
            }

            performMove(targetPileIndex, cardsDataToMove) {
                this.gameState.tableauPiles[this.originalPileIndex].splice(this.originalCardIndex);
                this.gameState.tableauPiles[targetPileIndex].push(...cardsDataToMove);
                
                const sourcePile = this.gameState.tableauPiles[this.originalPileIndex];
                if (sourcePile.length > 0) {
                    const newTopCard = sourcePile[sourcePile.length - 1];
                    if (!newTopCard.isFaceUp) {
                        newTopCard.isFaceUp = true;
                        this.gameState.score += 5;
                    }
                }
                
                this.gameState.moves++;
                
                const targetPile = this.gameState.tableauPiles[targetPileIndex];
                if (this.checkCompleteSequence(targetPile)) {
                    const completedSequence = targetPile.splice(targetPile.length - 13, 13);
                    this.gameState.foundations.push(completedSequence);
                    this.gameState.score += 100;
                    this.gameState.completedSequences++;
                    
                    if (targetPile.length > 0) {
                        const newTopCard = targetPile[targetPile.length - 1];
                        if (!newTopCard.isFaceUp) {
                            newTopCard.isFaceUp = true;
                            this.gameState.score += 5;
                        }
                    }
                    
                    this.checkWinState();
                }
                
                this.renderGame();
            }

            returnCardsToOriginalPosition() {
                this.originalPositions.forEach(pos => {
                    pos.element.style.top = pos.top;
                    pos.element.style.left = pos.left;
                    pos.element.style.position = pos.position;
                    pos.element.style.zIndex = pos.zIndex;
                });
                
                setTimeout(() => {
                    this.renderGame();
                }, 300);
            }

            cancelDrag() {
                if (this.isDragging) {
                    this.returnCardsToOriginalPosition();
                    this.cleanupDrag();
                }
            }

            cleanupDrag() {
                document.querySelectorAll('.tableau-pile.drag-over').forEach(pile => {
                    pile.classList.remove('drag-over');
                });
                
                if (this.draggedCards) {
                    this.draggedCards.forEach(card => {
                        card.classList.remove('dragging');
                        card.style.pointerEvents = '';
                        card.style.cursor = '';
                    });
                }
                
                this.draggedCards = null;
                this.isDragging = false;
                this.originalPositions = [];
                document.body.style.userSelect = '';
            }

            showHint() {
                const hints = [];
                
                for (let pileIndex = 0; pileIndex < 10; pileIndex++) {
                    const pile = this.gameState.tableauPiles[pileIndex];
                    if (pile.length === 0) continue;
                    
                    const topCard = pile[pile.length - 1];
                    if (!topCard.isFaceUp) continue;
                    
                    for (let targetIndex = 0; targetIndex < 10; targetIndex++) {
                        if (targetIndex === pileIndex) continue;
                        
                        if (this.isValidMove([topCard], targetIndex)) {
                            hints.push(`可以将 ${topCard.name}${this.getSuitSymbol(topCard.suit)} 从第${pileIndex + 1}桩移动到第${targetIndex + 1}桩`);
                        }
                    }
                }
                
                if (hints.length > 0) {
                    alert(hints[0]);
                } else {
                    alert("没有找到可行的移动，尝试发牌或重新排列");
                }
            }

            getSuitSymbol(suit) {
                const symbols = { 'spades': '♠', 'hearts': '♥', 'clubs': '♣', 'diamonds': '♦' };
                return symbols[suit] || suit;
            }

            winGame() {
                clearInterval(this.timerInterval);
                
                const timeBonus = Math.max(0, 1000 - Math.floor((Date.now() - this.startTime) / 1000));
                const finalScore = this.gameState.score + timeBonus;
                
                const elapsedTime = Date.now() - this.startTime;
                const minutes = Math.floor(elapsedTime / 60000);
                const seconds = Math.floor((elapsedTime % 60000) / 1000);
                const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                
                document.getElementById('final-time').textContent = formattedTime;
                document.getElementById('final-moves').textContent = this.gameState.moves;
                document.getElementById('final-score').textContent = finalScore;
                
                document.getElementById('fireworks').style.display = 'block';
                document.getElementById('win-message').style.display = 'block';
                
                this.startFireworks();
            }

            startFireworks() {
                const canvas = document.getElementById('fireworks');
                const ctx = canvas.getContext('2d');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                let particles = [];
                let animationId;
                
                const random = (min, max) => Math.random() * (max - min) + min;
                
                const createFirework = () => {
                    const x = random(100, canvas.width - 100);
                    const y = random(50, canvas.height / 2);
                    const colors = ['#30D158', '#0A84FF', '#AF52DE', '#FF9500', '#FF3B30', '#64D2FF'];
                    
                    for (let i = 0; i < 30; i++) {
                        particles.push({
                            x: x,
                            y: y,
                            vx: random(-6, 6),
                            vy: random(-6, 6),
                            life: 60,
                            maxLife: 60,
                            color: colors[Math.floor(Math.random() * colors.length)],
                            size: random(2, 4)
                        });
                    }
                };
                
                const animate = () => {
                    ctx.fillStyle = 'rgba(28, 28, 30, 0.1)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    particles.forEach((particle, index) => {
                        particle.x += particle.vx;
                        particle.y += particle.vy;
                        particle.vy += 0.15;
                        particle.life--;
                        
                        const alpha = particle.life / particle.maxLife;
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = particle.color;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * alpha, 0, Math.PI * 2);
                        ctx.fill();
                        
                        if (particle.life <= 0) {
                            particles.splice(index, 1);
                        }
                    });
                    
                    if (Math.random() < 0.04) {
                        createFirework();
                    }
                    
                    ctx.globalAlpha = 1;
                    animationId = requestAnimationFrame(animate);
                };
                
                animate();
                
                setTimeout(() => {
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                    }
                }, 8000);
            }

            restartGame() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                }
                
                document.getElementById('fireworks').style.display = 'none';
                document.getElementById('win-message').style.display = 'none';
                
                this.initializeGame();
            }
        }

        // Initialize the game
        const game = new SpiderSolitaire();
        
        // Prevent memory leaks on page unload
        window.addEventListener('beforeunload', () => {
            if (game.timerInterval) {
                clearInterval(game.timerInterval);
            }
            if (game.animationFrameId) {
                cancelAnimationFrame(game.animationFrameId);
            }
        });
    </script>
</body>
</html>
