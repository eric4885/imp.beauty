<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    
    <title>Imp Beauty - The Ultimate Imp Spider Solitaire Game</title>
    <meta name="description" content="Play Imp Beauty, a modern and elegant spider solitaire game. Enjoy a minimalist design with smooth gameplay on both desktop and mobile devices.">
    <link rel="canonical" href="https://imp.beauty/">

    <meta property="og:title" content="Imp Beauty - The Ultimate Imp Spider Solitaire Game">
    <meta property="og:description" content="Play Imp Beauty, a modern and elegant spider solitaire game. Enjoy a minimalist design with smooth gameplay on both desktop and mobile devices.">
    <meta property="og:url" content="https://imp.beauty/">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://imp.beauty/social-share-image.jpg">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Apple-inspired colors */
        :root {
            --color-dark-bg: #1C1C1E;
            --color-light-text: #F2F2F7;
            --color-accent-blue: #0A84FF;
            --color-accent-green: #30D158;
            --color-card-bg: #2C2C2E;
            --color-accent-purple: #AF52DE;
            --color-accent-orange: #FF9500;
            
            /* Game-specific variables */
            --card-width: 70px;
            --card-height: calc(var(--card-width) * 1.4);
            --card-radius: 8px;
            --card-bg-light: #F9FAFB;
            --card-bg-dark: var(--color-card-bg);
            --card-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            --red-suit: #FF3B30;
            --black-suit: #1C1C1E;
        }

        body {
            background-color: var(--color-dark-bg);
            color: var(--color-light-text);
            touch-action: manipulation;
        }

        /* Game state transitions */
        .landing-state {
            display: block;
        }
        .game-state {
            display: none;
        }
        
        .game-active .landing-state {
            display: none;
        }
        .game-active .game-state {
            display: block;
        }

        /* Hero section animations */
        .hero-title {
            background: linear-gradient(135deg, var(--color-accent-green), var(--color-accent-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { filter: brightness(1); }
            to { filter: brightness(1.2); }
        }

        .play-button {
            background: linear-gradient(135deg, var(--color-accent-green), var(--color-accent-blue));
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 10px 25px rgba(48, 209, 88, 0.3);
        }

        .play-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 20px 40px rgba(48, 209, 88, 0.4);
        }

        /* Card game styles */
        .card-container {
            width: var(--card-width);
            height: var(--card-height);
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            cursor: pointer;
            perspective: 1000px;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .card-container.transitioning {
            transition: transform 0.6s, top 0.3s ease, left 0.3s ease;
        }

        .card-container.dragging {
            z-index: 1000 !important;
            pointer-events: none;
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: var(--card-radius);
            box-shadow: var(--card-shadow);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }

        .card-front {
            background-color: var(--card-bg-light);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: var(--black-suit);
        }
        .card-front.is-red {
            color: var(--red-suit);
        }
        .card-front .card-value {
            font-size: 1.2rem;
            font-weight: bold;
            line-height: 1;
        }
        .card-front .suit-symbol {
             font-size: 1.5rem;
        }

        .card-back {
            background: linear-gradient(135deg, var(--color-card-bg), #3A3A3C);
            transform: rotateY(180deg);
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card-container.is-flipped {
            transform: rotateY(180deg);
        }

        .tableau-pile {
            position: relative;
            padding-top: 15px;
            min-height: calc(var(--card-height) + 80px);
            border: 2px dashed transparent;
            border-radius: var(--card-radius);
            transition: border-color 0.2s;
            /* ç¡®ä¿æœ‰è¶³å¤Ÿçš„ç‚¹å‡»åŒºåŸŸ */
            padding-bottom: 60px;
        }

        .tableau-pile.drag-over {
            border-color: var(--color-accent-blue);
            background-color: rgba(10, 132, 255, 0.1);
        }

        .tableau-pile .card-container {
            position: absolute;
            top: 0;
            left: 0;
            transition: top 0.3s ease;
        }

        #stock-pile {
            width: var(--card-width);
            height: var(--card-height);
            position: relative;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        #stock-pile:hover {
            transform: scale(1.05);
        }

        #stock-pile .card-back {
            position: absolute;
            top: 0;
            left: 0;
        }

        #foundations {
            display: flex;
            gap: 8px;
        }
        .foundation-pile {
             width: var(--card-width);
             height: var(--card-height);
             border: 2px solid rgba(255, 255, 255, 0.3);
             border-radius: var(--card-radius);
             display: flex;
             align-items: center;
             justify-content: center;
        }
        .foundation-pile .card-container {
            position: relative;
        }

        .foundation-pile.empty {
            background-color: rgba(255, 255, 255, 0.05);
        }

        #game-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            color: var(--color-light-text);
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }

        #fireworks {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
            z-index: 9999;
        }
        
        #win-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 0 0 10px black;
            display: none;
            text-align: center;
            z-index: 10000;
            background: linear-gradient(135deg, rgba(48, 209, 88, 0.9), rgba(10, 132, 255, 0.9));
            padding: 2rem;
            border-radius: 20px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn {
            background: var(--color-accent-blue);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border: none;
            color: white;
            font-weight: 500;
        }
        .btn:hover { 
            background: #0056CC;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(10, 132, 255, 0.3);
        }
        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            :root {
                --card-width: 60px;
            }
            .card-front .card-value {
                font-size: 1rem;
            }
            .card-front .suit-symbol {
                font-size: 1.2rem;
            }
            .hero-title {
                font-size: 3rem !important;
            }
        }

        /* Animations */
        @media (prefers-reduced-motion: reduce) {
            .card-container {
                transition: none;
            }
        }

        .fade-in {
            animation: fadeIn 0.6s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: var(--color-dark-bg);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--color-accent-blue);
            border-radius: 4px;
        }
    </style>
</head>
<body class="font-sans antialiased text-white">

    <!-- Landing Page State -->
    <div class="landing-state">
        <div class="min-h-screen flex flex-col items-center justify-center p-4">
            <header class="text-center mb-8">
                <h1 class="hero-title text-6xl md:text-8xl font-bold tracking-tight">Imp Beauty</h1>
                <p class="mt-4 text-lg md:text-xl font-light text-gray-400">The most elegant spider solitaire game you'll ever play.</p>
            </header>

            <main class="w-full max-w-2xl text-center">
                <p class="text-xl md:text-2xl font-medium leading-relaxed mb-8">
                    Unwind with <span style="color: var(--color-accent-blue);" class="font-bold">Imp Beauty</span>, a beautifully designed spider solitaire experience. With a minimalist interface and fluid animations, it's the perfect way to pass the time.
                </p>

                <div class="mb-8">
                    <button id="start-game-btn" class="play-button text-white text-xl font-bold py-4 px-8 rounded-2xl">
                        ğŸ´ Start Playing
                    </button>
                </div>

                <div id="game-preview" class="w-full bg-gray-800 rounded-2xl shadow-xl border-4 mb-12" style="border-color: var(--color-card-bg);">
                    <div class="h-96 md:h-[500px] flex items-center justify-center text-xl font-semibold text-gray-400 p-8">
                        <div class="text-center">
                            <div class="text-6xl mb-4">ğŸ´</div>
                            <div class="text-lg">Click "Start Playing" to begin your adventure</div>
                            <div class="text-sm text-gray-500 mt-2">No registration required â€¢ Play instantly</div>
                        </div>
                    </div>
                </div>

                <div class="text-left space-y-6">
                    <h2 class="text-3xl font-bold" style="color: var(--color-accent-blue);">Game Overview</h2>
                    <p class="text-base leading-relaxed text-gray-400">
                        <strong class="text-white">Imp Beauty</strong> is a modern take on the classic spider solitaire game. The goal is to create sets of cards from King to Ace, which are then removed from the tableau. The game is designed for a seamless experience on any device, from a large desktop monitor to a smartphone.
                    </p>
                    <ul class="list-disc list-inside space-y-2 text-base text-gray-400">
                        <li><strong class="text-white">Fluid Gameplay:</strong> Drag and drop cards with smooth, intuitive controls.</li>
                        <li><strong class="text-white">Minimalist Design:</strong> A clean interface that lets you focus on the game, not the clutter.</li>
                        <li><strong class="text-white">Adaptive Display:</strong> Automatically adjusts to your screen size for optimal play.</li>
                        <li><strong class="text-white">Offline Mode:</strong> Play anytime, anywhere, with no internet required.</li>
                        <li><strong class="text-white">Score System:</strong> Challenge yourself with our intelligent scoring system.</li>
                        <li><strong class="text-white">Hint System:</strong> Get helpful suggestions when you're stuck.</li>
                    </ul>
                </div>
            </main>

            <footer class="mt-12 text-center text-sm font-light text-gray-500">
                <p>&copy; 2025 Imp.Beauty. All rights reserved.</p>
            </footer>
        </div>
    </div>

    <!-- Game State -->
    <div class="game-state">
        <div class="p-4 md:p-6 max-w-7xl mx-auto">
            <!-- Game Header -->
            <div class="text-center mb-6">
                <h1 class="text-2xl md:text-3xl font-bold" style="color: var(--color-accent-green);">Imp Beauty</h1>
                <button id="back-to-landing" class="mt-2 text-sm text-gray-400 hover:text-white transition-colors">â† Back to Home</button>
            </div>

            <!-- Game Stats -->
            <div id="game-stats" class="flex justify-between items-center mb-4 text-sm">
                <div class="flex gap-4">
                    <span id="moves-counter">æ­¥æ•°: 0</span>
                    <span id="timer-counter">æ—¶é—´: 00:00</span>
                    <span id="score-counter">å¾—åˆ†: 0</span>
                </div>
                <div class="flex gap-2">
                    <button id="hint-btn" class="btn btn-secondary">ğŸ’¡ æç¤º</button>
                    <button id="restart-btn-top" class="btn">ğŸ”„ é‡æ–°å¼€å§‹</button>
                </div>
            </div>
            
            <!-- Stock and Foundations -->
            <div class="flex justify-between items-start mb-4">
                <div class="flex flex-col items-center">
                    <div id="stock-pile">
                        <div class="card-face card-back">
                             <span class="text-white text-sm font-bold">IMP</span>
                        </div>
                    </div>
                    <div class="text-center text-xs text-gray-400 mt-1">
                        å‰©ä½™: <span id="stock-count">50</span>
                    </div>
                </div>
                
                <div id="foundations" class="flex flex-wrap justify-end gap-1">
                    <!-- Foundation piles will be rendered here -->
                </div>
            </div>

            <!-- Game Board -->
            <div id="game-board" class="grid grid-cols-5 md:grid-cols-10 gap-1 md:gap-2">
                <div id="pile-0" class="tableau-pile"></div>
                <div id="pile-1" class="tableau-pile"></div>
                <div id="pile-2" class="tableau-pile"></div>
                <div id="pile-3" class="tableau-pile"></div>
                <div id="pile-4" class="tableau-pile"></div>
                <div id="pile-5" class="tableau-pile"></div>
                <div id="pile-6" class="tableau-pile"></div>
                <div id="pile-7" class="tableau-pile"></div>
                <div id="pile-8" class="tableau-pile"></div>
                <div id="pile-9" class="tableau-pile"></div>
            </div>
        </div>
    </div>
    
    <!-- Game Win Elements -->
    <canvas id="fireworks"></canvas>
    <div id="win-message">
        ğŸ‰ æ­å–œè·èƒœï¼ ğŸ‰<br>
        <div class="mt-4 text-base font-normal">
            å®Œæˆæ—¶é—´: <span id="final-time"></span><br>
            æ€»æ­¥æ•°: <span id="final-moves"></span><br>
            æœ€ç»ˆå¾—åˆ†: <span id="final-score"></span>
        </div>
        <div class="mt-6 flex gap-3 justify-center">
            <button id="restart-btn-win" class="btn">ğŸ® å†ç©ä¸€å±€</button>
            <button id="back-to-home-win" class="btn btn-secondary">ğŸ  è¿”å›é¦–é¡µ</button>
        </div>
    </div>

    <script>
        class Card {
            constructor(suit, value, name) {
                this.suit = suit;
                this.value = value;
                this.name = name;
                this.isFaceUp = false;
                this.id = `${suit}_${value}_${Math.random().toString(36).substr(2, 9)}`;
            }
        }

        class SpiderSolitaire {
            constructor() {
                console.log('SpiderSolitaire æ„é€ å‡½æ•°è¢«è°ƒç”¨'); // è°ƒè¯•æ—¥å¿—
                this.gameState = null;
                this.timerInterval = null;
                this.startTime = null;
                this.draggedCards = null;
                this.originalPileIndex = null;
                this.originalCardIndex = null;
                this.originalPositions = [];
                this.isDragging = false;
                this.animationFrameId = null;
                
                console.log('å¼€å§‹åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨'); // è°ƒè¯•æ—¥å¿—
                this.initializeEventListeners();
                console.log('äº‹ä»¶ç›‘å¬å™¨åˆå§‹åŒ–å®Œæˆ'); // è°ƒè¯•æ—¥å¿—
            }

            createAndShuffleDeck() {
                const suits = ['spades', 'hearts', 'clubs', 'diamonds'];
                const values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];
                const cardNames = {
                    1: 'A', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7',
                    8: '8', 9: '9', 10: '10', 11: 'J', 12: 'Q', 13: 'K'
                };

                let deck = [];
                for (let i = 0; i < 2; i++) {
                    for (const suit of suits) {
                        for (const value of values) {
                            deck.push(new Card(suit, value, cardNames[value]));
                        }
                    }
                }
                
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
                
                return deck;
            }

            initializeGame(shuffledDeck = null) {
                console.log('åˆå§‹åŒ–æ¸¸æˆå¼€å§‹'); // è°ƒè¯•æ—¥å¿—
                
                if (!shuffledDeck) {
                    shuffledDeck = this.createAndShuffleDeck();
                }

                console.log('åˆ›å»ºäº†', shuffledDeck.length, 'å¼ ç‰Œ'); // è°ƒè¯•æ—¥å¿—

                this.gameState = {
                    tableauPiles: Array.from({ length: 10 }, () => []),
                    stockPiles: [],
                    foundations: [],
                    moves: 0,
                    score: 500,
                    completedSequences: 0
                };

                let cardIndex = 0;
                const cardsPerPile = [6, 6, 6, 6, 5, 5, 5, 5, 5, 5];

                // åˆ†å‘åˆå§‹ç‰Œ
                for (let pileIndex = 0; pileIndex < 10; pileIndex++) {
                    console.log(`ä¸ºæ¡© ${pileIndex} åˆ†å‘ ${cardsPerPile[pileIndex]} å¼ ç‰Œ`);
                    for (let i = 0; i < cardsPerPile[pileIndex]; i++) {
                        if (cardIndex < shuffledDeck.length) {
                            let card = shuffledDeck[cardIndex];
                            this.gameState.tableauPiles[pileIndex].push(card);
                            cardIndex++;
                        }
                    }
                    // ç¿»å¼€æ¯å †çš„é¡¶ç‰Œ
                    let topCard = this.gameState.tableauPiles[pileIndex][this.gameState.tableauPiles[pileIndex].length - 1];
                    if (topCard) {
                        topCard.isFaceUp = true;
                        console.log(`æ¡© ${pileIndex} é¡¶ç‰Œ ${topCard.name} å·²ç¿»å¼€`);
                    }
                }
                
                // å‰©ä½™çš„ç‰Œæ”¾å…¥åº“å­˜
                this.gameState.stockPiles = shuffledDeck.slice(cardIndex);
                console.log('åº“å­˜ç‰Œæ•°:', this.gameState.stockPiles.length);
                
                // éªŒè¯åˆ†å‘ç»“æœ
                const totalCards = this.gameState.tableauPiles.reduce((sum, pile) => sum + pile.length, 0) + this.gameState.stockPiles.length;
                console.log('æ€»ç‰Œæ•°éªŒè¯:', totalCards, 'åº”ä¸º 104');
                
                this.startTimer();
                
                console.log('æ¸¸æˆåˆå§‹åŒ–å®Œæˆï¼Œå‡†å¤‡æ¸²æŸ“');
                // ä¸åœ¨è¿™é‡Œè°ƒç”¨ renderGameï¼Œç”± startGame è°ƒç”¨
            }

            startTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                this.startTime = Date.now();
                this.timerInterval = setInterval(() => this.updateTimer(), 1000);
            }

            updateTimer() {
                if (!this.startTime) return;
                
                const elapsedTime = Date.now() - this.startTime;
                const minutes = Math.floor(elapsedTime / 60000);
                const seconds = Math.floor((elapsedTime % 60000) / 1000);
                
                const formattedMinutes = String(minutes).padStart(2, '0');
                const formattedSeconds = String(seconds).padStart(2, '0');
                
                document.getElementById('timer-counter').textContent = `æ—¶é—´: ${formattedMinutes}:${formattedSeconds}`;
            }

            renderGame() {
                console.log('å¼€å§‹æ¸²æŸ“æ¸¸æˆ'); // è°ƒè¯•æ—¥å¿—
                if (!this.gameState) {
                    console.error('æ¸¸æˆçŠ¶æ€ä¸ºç©ºï¼Œæ— æ³•æ¸²æŸ“');
                    return;
                }

                console.log('æ¸²æŸ“æ¸¸æˆçŠ¶æ€:', {
                    moves: this.gameState.moves,
                    score: this.gameState.score,
                    stockPiles: this.gameState.stockPiles.length,
                    tableauPiles: this.gameState.tableauPiles.map(pile => pile.length)
                });

                this.updateGameStats();
                this.renderStockPile();
                this.renderFoundations();
                this.renderTableauPiles();
                
                console.log('æ¸¸æˆæ¸²æŸ“å®Œæˆ');
            }

            updateGameStats() {
                document.getElementById('moves-counter').textContent = `æ­¥æ•°: ${this.gameState.moves}`;
                document.getElementById('score-counter').textContent = `å¾—åˆ†: ${this.gameState.score}`;
                document.getElementById('stock-count').textContent = this.gameState.stockPiles.length;
            }

            renderStockPile() {
                const stockPileElement = document.getElementById('stock-pile');
                if (this.gameState.stockPiles.length > 0) {
                    stockPileElement.style.opacity = '1';
                    stockPileElement.style.cursor = 'pointer';
                } else {
                    stockPileElement.style.opacity = '0.5';
                    stockPileElement.style.cursor = 'not-allowed';
                }
            }

            renderFoundations() {
                const foundationsElement = document.getElementById('foundations');
                foundationsElement.innerHTML = '';
                
                this.gameState.foundations.forEach((foundationPile, index) => {
                    const foundationContainer = document.createElement('div');
                    foundationContainer.className = 'foundation-pile';
                    
                    if (foundationPile.length > 0) {
                        const topCard = foundationPile[foundationPile.length - 1];
                        const isRed = topCard.suit === 'hearts' || topCard.suit === 'diamonds';
                        const suitSymbols = { 'spades': 'â™ ', 'hearts': 'â™¥', 'clubs': 'â™£', 'diamonds': 'â™¦' };
                        
                        foundationContainer.innerHTML = `
                            <div class="card-container is-flipped">
                                <div class="card-face card-back"></div>
                                <div class="card-face card-front ${isRed ? 'is-red' : ''}">
                                    <span class="card-value self-start p-1">${topCard.name}</span>
                                    <span class="suit-symbol">${suitSymbols[topCard.suit]}</span>
                                    <span class="card-value self-end p-1 rotate-180">${topCard.name}</span>
                                </div>
                            </div>
                        `;
                    } else {
                        foundationContainer.classList.add('empty');
                        foundationContainer.innerHTML = '<span class="text-gray-500 text-xs">å®Œæˆæ¡©</span>';
                    }
                    
                    foundationsElement.appendChild(foundationContainer);
                });
            }

            renderTableauPiles() {
                console.log('å¼€å§‹æ¸²æŸ“tableau piles'); // è°ƒè¯•æ—¥å¿—
                const suitSymbols = { 'spades': 'â™ ', 'hearts': 'â™¥', 'clubs': 'â™£', 'diamonds': 'â™¦' };
                
                this.gameState.tableauPiles.forEach((pile, pileIndex) => {
                    const pileElement = document.getElementById(`pile-${pileIndex}`);
                    if (!pileElement) {
                        console.error(`æ‰¾ä¸åˆ°æ¡©å…ƒç´ : pile-${pileIndex}`);
                        return;
                    }
                    
                    console.log(`æ¸²æŸ“æ¡© ${pileIndex}ï¼ŒåŒ…å« ${pile.length} å¼ ç‰Œ`);
                    pileElement.innerHTML = '';
                    
                    pile.forEach((card, cardIndex) => {
                        const cardContainer = document.createElement('div');
                        cardContainer.className = 'card-container';
                        cardContainer.dataset.cardIndex = cardIndex.toString();
                        cardContainer.dataset.pileIndex = pileIndex.toString();
                        cardContainer.dataset.cardId = card.id;
                        
                        const topOffset = cardIndex * 15;
                        cardContainer.style.top = `${topOffset}px`;
                        cardContainer.style.position = 'absolute';
                        cardContainer.style.left = '0px';
                        
                        const isRed = card.suit === 'hearts' || card.suit === 'diamonds';
                        
                        const cardBack = document.createElement('div');
                        cardBack.className = 'card-face card-back';
                        cardBack.innerHTML = '<span class="text-white text-xs font-bold">IMP</span>';

                        const cardFront = document.createElement('div');
                        cardFront.className = `card-face card-front ${isRed ? 'is-red' : ''}`;
                        cardFront.innerHTML = `
                            <span class="card-value self-start p-1">${card.name}</span>
                            <span class="suit-symbol">${suitSymbols[card.suit]}</span>
                            <span class="card-value self-end p-1 rotate-180">${card.name}</span>
                        `;

                        cardContainer.appendChild(cardBack);
                        cardContainer.appendChild(cardFront);

                        if (card.isFaceUp) {
                            cardContainer.classList.add('is-flipped');
                            cardContainer.style.cursor = 'grab';
                            cardContainer.setAttribute('draggable', 'false');
                            console.log(`ç‰Œ ${card.name}${suitSymbols[card.suit]} å·²ç¿»å¼€ï¼Œå¯æ‹–æ‹½`);
                        } else {
                            cardContainer.style.cursor = 'default';
                        }

                        pileElement.appendChild(cardContainer);
                    });
                });
                
                console.log('tableau piles æ¸²æŸ“å®Œæˆ');
            }

            checkCompleteSequence(pile) {
                if (pile.length < 13) return false;
                
                const sequence = pile.slice(-13);
                const topCard = sequence[12];
                
                if (topCard.value !== 1) return false;
                
                for (let i = 0; i < 12; i++) {
                    const currentCard = sequence[i];
                    const nextCard = sequence[i + 1];
                    
                    if (currentCard.value !== nextCard.value + 1 || 
                        currentCard.suit !== nextCard.suit) {
                        return false;
                    }
                }
                
                return true;
            }

            checkWinState() {
                let totalFoundationCards = 0;
                this.gameState.foundations.forEach(pile => {
                    totalFoundationCards += pile.length;
                });

                if (totalFoundationCards === 104) {
                    this.winGame();
                }
            }

            dealCards() {
                if (this.gameState.stockPiles.length === 0) {
                    console.log("åº“å­˜ç‰Œå·²ç”¨å®Œ");
                    return;
                }

                for (let i = 0; i < 10; i++) {
                    if (this.gameState.tableauPiles[i].length === 0) {
                        alert("æœ‰ç©ºæ¡©æ—¶æ— æ³•å‘ç‰Œï¼Œè¯·å…ˆç§»åŠ¨ç‰Œåˆ°ç©ºæ¡©");
                        return;
                    }
                }

                for (let i = 0; i < 10; i++) {
                    if (this.gameState.stockPiles.length > 0) {
                        const cardToDeal = this.gameState.stockPiles.shift();
                        cardToDeal.isFaceUp = true;
                        this.gameState.tableauPiles[i].push(cardToDeal);
                    }
                }
                
                this.gameState.moves++;
                this.gameState.score -= 1;
                this.renderGame();
                this.checkForAutoFlips();
            }

            checkForAutoFlips() {
                let hasFlipped = false;
                this.gameState.tableauPiles.forEach(pile => {
                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        if (!topCard.isFaceUp) {
                            topCard.isFaceUp = true;
                            hasFlipped = true;
                        }
                    }
                });
                
                if (hasFlipped) {
                    setTimeout(() => this.renderGame(), 100);
                }
            }

            isValidMove(draggedCardsData, targetPileIndex) {
                if (!draggedCardsData || draggedCardsData.length === 0) return false;
                
                const targetPile = this.gameState.tableauPiles[targetPileIndex];
                const firstDraggedCard = draggedCardsData[0];
                
                if (targetPile.length === 0) {
                    return true;
                }

                const topCardOfTargetPile = targetPile[targetPile.length - 1];
                return firstDraggedCard.value === topCardOfTargetPile.value - 1;
            }

            isValidDragSequence(cards) {
                if (cards.length === 1) return true;
                
                for (let i = 0; i < cards.length - 1; i++) {
                    const currentCard = cards[i];
                    const nextCard = cards[i + 1];
                    
                    if (currentCard.value !== nextCard.value + 1 || 
                        currentCard.suit !== nextCard.suit) {
                        return false;
                    }
                }
                return true;
            }

            getDropTarget(x, y) {
                console.log('æ£€æµ‹æ‹–æ”¾ç›®æ ‡ï¼Œåæ ‡:', x, y); // è°ƒè¯•æ—¥å¿—
                
                if (!x || !y) {
                    console.log('æ— æ•ˆåæ ‡'); // è°ƒè¯•æ—¥å¿—
                    return null;
                }
                
                // é¦–å…ˆå°è¯•ç”¨elementsFromPoint
                try {
                    const elements = document.elementsFromPoint(x, y);
                    console.log('åæ ‡ä¸‹çš„å…ƒç´ :', elements.map(el => el.className || el.tagName)); // è°ƒè¯•æ—¥å¿—
                    
                    for (const element of elements) {
                        // è·³è¿‡æ­£åœ¨æ‹–æ‹½çš„å…ƒç´ 
                        if (element.classList.contains('dragging')) continue;
                        
                        const pile = element.closest('.tableau-pile');
                        if (pile) {
                            console.log('æ‰¾åˆ°ç›®æ ‡æ¡©:', pile.id); // è°ƒè¯•æ—¥å¿—
                            return pile;
                        }
                    }
                } catch (e) {
                    console.error('elementsFromPoint å‡ºé”™:', e);
                }
                
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œæ‰‹åŠ¨æ£€æŸ¥æ¯ä¸ªæ¡©çš„è¾¹ç•Œ
                const piles = document.querySelectorAll('.tableau-pile');
                console.log('æ‰‹åŠ¨æ£€æŸ¥', piles.length, 'ä¸ªæ¡©'); // è°ƒè¯•æ—¥å¿—
                
                for (const pile of piles) {
                    const rect = pile.getBoundingClientRect();
                    const margin = 30; // å¢å¤§æ£€æµ‹è¾¹è·
                    
                    if (x >= rect.left - margin && 
                        x <= rect.right + margin && 
                        y >= rect.top - margin && 
                        y <= rect.bottom + margin + 120) { // å¢åŠ æ›´å¤§çš„åº•éƒ¨åŒºåŸŸ
                        console.log('è¾¹ç•Œæ£€æµ‹æ‰¾åˆ°ç›®æ ‡æ¡©:', pile.id); // è°ƒè¯•æ—¥å¿—
                        return pile;
                    }
                }
                
                console.log('æ²¡æœ‰æ‰¾åˆ°ç›®æ ‡æ¡©'); // è°ƒè¯•æ—¥å¿—
                return null;
            }

            initializeEventListeners() {
                console.log('æ­£åœ¨åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨'); // è°ƒè¯•æ—¥å¿—
                
                // æ£€æŸ¥å…³é”®å…ƒç´ æ˜¯å¦å­˜åœ¨
                const startBtn = document.getElementById('start-game-btn');
                const backBtn = document.getElementById('back-to-landing');
                
                console.log('å¼€å§‹æŒ‰é’®:', startBtn ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
                console.log('è¿”å›æŒ‰é’®:', backBtn ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
                
                // Landing page to game transition
                if (startBtn) {
                    startBtn.addEventListener('click', () => {
                        console.log('å¼€å§‹æŒ‰é’®è¢«ç‚¹å‡»'); // è°ƒè¯•æ—¥å¿—
                        this.startGame();
                    });
                } else {
                    console.error('æ‰¾ä¸åˆ°å¼€å§‹æ¸¸æˆæŒ‰é’®');
                }

                if (backBtn) {
                    backBtn.addEventListener('click', () => {
                        this.backToLanding();
                    });
                }

                const backWinBtn = document.getElementById('back-to-home-win');
                if (backWinBtn) {
                    backWinBtn.addEventListener('click', () => {
                        this.backToLanding();
                    });
                }

                // Game controls - using event delegation to handle dynamic elements
                document.addEventListener('click', (e) => {
                    if (e.target.closest('#stock-pile')) {
                        console.log('åº“å­˜æ¡©è¢«ç‚¹å‡»'); // è°ƒè¯•æ—¥å¿—
                        this.dealCards();
                    } else if (e.target.closest('#restart-btn-top')) {
                        this.restartGame();
                    } else if (e.target.closest('#restart-btn-win')) {
                        this.restartGame();
                    } else if (e.target.closest('#hint-btn')) {
                        this.showHint();
                    }
                });

                // Drag events - using event delegation for dynamic card elements
                document.addEventListener('mousedown', (e) => this.handleStart(e));
                document.addEventListener('touchstart', (e) => this.handleStart(e), { passive: false });
                
                document.addEventListener('mousemove', (e) => this.handleMove(e));
                document.addEventListener('touchmove', (e) => this.handleMove(e), { passive: false });
                
                document.addEventListener('mouseup', (e) => this.handleEnd(e));
                document.addEventListener('touchend', (e) => this.handleEnd(e));

                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.isDragging) {
                        this.cancelDrag();
                    }
                });
                
                console.log('äº‹ä»¶ç›‘å¬å™¨è®¾ç½®å®Œæˆ'); // è°ƒè¯•æ—¥å¿—
            }

            startGame() {
                console.log('å¼€å§‹æ¸¸æˆ'); // è°ƒè¯•æ—¥å¿—
                document.body.classList.add('game-active');
                document.body.classList.add('fade-in');
                
                // ç¡®ä¿æ¸¸æˆçŠ¶æ€è¢«æ­£ç¡®åˆå§‹åŒ–
                this.initializeGame();
                
                // æ·»åŠ ä¸€ä¸ªå°å»¶è¿Ÿç¡®ä¿DOMæ›´æ–°å®Œæˆ
                setTimeout(() => {
                    console.log('æ¸¸æˆçŠ¶æ€:', this.gameState);
                    console.log('tableau piles:', this.gameState?.tableauPiles?.map(pile => pile.length));
                    this.renderGame();
                }, 100);
            }

            backToLanding() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                document.getElementById('fireworks').style.display = 'none';
                document.getElementById('win-message').style.display = 'none';
                document.body.classList.remove('game-active');
                this.gameState = null;
            }

            handleStart(e) {
                // åªåœ¨æ¸¸æˆæ¨¡å¼ä¸‹å¤„ç†æ‹–æ‹½
                if (!document.body.classList.contains('game-active')) return;
                
                const cardElement = e.target.closest('.card-container');
                if (!cardElement || !cardElement.classList.contains('is-flipped')) {
                    return;
                }

                // é˜²æ­¢é»˜è®¤è¡Œä¸º
                e.preventDefault();
                e.stopPropagation();
                
                console.log('å¼€å§‹æ‹–æ‹½ï¼Œå¡ç‰‡:', cardElement.dataset); // è°ƒè¯•æ—¥å¿—
                
                this.originalPileIndex = parseInt(cardElement.dataset.pileIndex);
                this.originalCardIndex = parseInt(cardElement.dataset.cardIndex);
                
                if (isNaN(this.originalPileIndex) || isNaN(this.originalCardIndex)) {
                    console.error('æ— æ•ˆçš„æ¡©ç´¢å¼•æˆ–å¡ç‰‡ç´¢å¼•');
                    return;
                }
                
                const pile = this.gameState.tableauPiles[this.originalPileIndex];
                if (!pile || this.originalCardIndex >= pile.length) {
                    console.error('æ‰¾ä¸åˆ°å¯¹åº”çš„ç‰Œå †æˆ–å¡ç‰‡');
                    return;
                }
                
                const cardsToCheck = pile.slice(this.originalCardIndex);
                
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ‹–æ‹½è¿™ä¸ªåºåˆ—
                if (!this.isValidDragSequence(cardsToCheck)) {
                    if (cardsToCheck.length > 1) {
                        console.log('æ— æ•ˆçš„æ‹–æ‹½åºåˆ—ï¼Œåªèƒ½æ‹–æ‹½å•å¼ ç‰Œ');
                        return;
                    }
                }
                
                // è·å–è¦æ‹–æ‹½çš„æ‰€æœ‰DOMå…ƒç´ 
                const allCardsInPile = Array.from(cardElement.parentElement.children);
                const cardsToDrag = allCardsInPile.slice(this.originalCardIndex);
                
                this.draggedCards = cardsToDrag;
                this.isDragging = true;
                
                console.log('å‡†å¤‡æ‹–æ‹½', cardsToDrag.length, 'å¼ ç‰Œ'); // è°ƒè¯•æ—¥å¿—
                
                // ä¿å­˜åŸå§‹ä½ç½®
                this.originalPositions = this.draggedCards.map(card => ({
                    element: card,
                    top: card.style.top,
                    left: card.style.left || '0px',
                    position: card.style.position || 'absolute',
                    zIndex: card.style.zIndex || 'auto'
                }));
                
                // è®¾ç½®æ‹–æ‹½æ ·å¼
                this.draggedCards.forEach((card, index) => {
                    card.classList.add('dragging');
                    card.style.position = 'fixed';
                    card.style.zIndex = (1000 + index).toString();
                    card.style.pointerEvents = 'none';
                    card.style.cursor = 'grabbing';
                });
                
                // è·å–é¼ æ ‡/è§¦æ‘¸ä½ç½®
                const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
                const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
                
                // è®¡ç®—åç§»é‡
                const rect = cardElement.getBoundingClientRect();
                this.offsetX = clientX - rect.left;
                this.offsetY = clientY - rect.top;
                
                console.log('æ‹–æ‹½å¼€å§‹ä½ç½®:', clientX, clientY); // è°ƒè¯•æ—¥å¿—
                
                // è®¾ç½®åˆå§‹æ‹–æ‹½ä½ç½®
                this.updateDragPosition(clientX, clientY);
                
                document.body.style.userSelect = 'none';
                document.body.style.cursor = 'grabbing';
            }

            handleMove(e) {
                if (!this.isDragging || !this.draggedCards || this.draggedCards.length === 0) return;
                
                e.preventDefault();
                e.stopPropagation();
                
                const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
                const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
                
                this.updateDragPosition(clientX, clientY);
                this.highlightDropTargets(clientX, clientY);
            }

            updateDragPosition(clientX, clientY) {
                if (!this.draggedCards || this.draggedCards.length === 0) return;
                
                this.draggedCards.forEach((card, index) => {
                    if (card && card.style) {
                        const newLeft = clientX - this.offsetX;
                        const newTop = clientY - this.offsetY + (index * 15);
                        
                        card.style.left = `${newLeft}px`;
                        card.style.top = `${newTop}px`;
                    }
                });
            }

            highlightDropTargets(clientX, clientY) {
                // ç§»é™¤ä¹‹å‰çš„é«˜äº®
                document.querySelectorAll('.tableau-pile.drag-over').forEach(pile => {
                    pile.classList.remove('drag-over');
                });
                
                // é«˜äº®å½“å‰æ‚¬åœçš„æ¡©
                const dropTarget = this.getDropTarget(clientX, clientY);
                if (dropTarget) {
                    const targetPileIndex = parseInt(dropTarget.id.replace('pile-', ''));
                    const draggedCardsData = this.gameState.tableauPiles[this.originalPileIndex]
                        .slice(this.originalCardIndex);
                    
                    // ç¡®ä¿ä¸æ˜¯åŒä¸€ä¸ªæ¡©ï¼Œå¹¶ä¸”ç§»åŠ¨æœ‰æ•ˆ
                    if (targetPileIndex !== this.originalPileIndex && 
                        this.isValidMove(draggedCardsData, targetPileIndex)) {
                        dropTarget.classList.add('drag-over');
                    }
                }
            }

            handleEnd(e) {
                if (!this.isDragging || !this.draggedCards || this.draggedCards.length === 0) return;
                
                console.log('ç»“æŸæ‹–æ‹½'); // è°ƒè¯•æ—¥å¿—
                
                const clientX = e.clientX || (e.changedTouches && e.changedTouches[0] ? e.changedTouches[0].clientX : 0);
                const clientY = e.clientY || (e.changedTouches && e.changedTouches[0] ? e.changedTouches[0].clientY : 0);
                
                console.log('æ”¾ä¸‹ä½ç½®:', clientX, clientY); // è°ƒè¯•æ—¥å¿—
                
                const dropTarget = this.getDropTarget(clientX, clientY);
                console.log('ç›®æ ‡æ¡©:', dropTarget ? dropTarget.id : 'æ— '); // è°ƒè¯•æ—¥å¿—
                
                const cardsDataToMove = this.gameState.tableauPiles[this.originalPileIndex]
                    .slice(this.originalCardIndex);
                
                let moveSuccessful = false;
                
                if (dropTarget) {
                    const targetPileIndex = parseInt(dropTarget.id.replace('pile-', ''));
                    console.log('ç›®æ ‡æ¡©ç´¢å¼•:', targetPileIndex, 'åŸå§‹æ¡©ç´¢å¼•:', this.originalPileIndex); // è°ƒè¯•æ—¥å¿—
                    
                    // ç¡®ä¿ä¸æ˜¯ç§»åŠ¨åˆ°åŒä¸€ä¸ªä½ç½®ï¼Œå¹¶ä¸”ç§»åŠ¨æœ‰æ•ˆ
                    if (targetPileIndex !== this.originalPileIndex && 
                        this.isValidMove(cardsDataToMove, targetPileIndex)) {
                        console.log('æ‰§è¡Œç§»åŠ¨'); // è°ƒè¯•æ—¥å¿—
                        this.performMove(targetPileIndex, cardsDataToMove);
                        moveSuccessful = true;
                    } else {
                        console.log('ç§»åŠ¨æ— æ•ˆæˆ–åŒæ¡©ç§»åŠ¨'); // è°ƒè¯•æ—¥å¿—
                    }
                } else {
                    console.log('æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„ç›®æ ‡æ¡©'); // è°ƒè¯•æ—¥å¿—
                }
                
                if (!moveSuccessful) {
                    console.log('è¿”å›åŸä½ç½®'); // è°ƒè¯•æ—¥å¿—
                    this.returnCardsToOriginalPosition();
                }
                
                this.cleanupDrag();
            }

            performMove(targetPileIndex, cardsDataToMove) {
                // æ‰§è¡Œå®é™…çš„æ•°æ®ç§»åŠ¨
                this.gameState.tableauPiles[this.originalPileIndex].splice(this.originalCardIndex);
                this.gameState.tableauPiles[targetPileIndex].push(...cardsDataToMove);
                
                // ç¿»å¼€æºæ¡©çš„æ–°é¡¶ç‰Œ
                const sourcePile = this.gameState.tableauPiles[this.originalPileIndex];
                if (sourcePile.length > 0) {
                    const newTopCard = sourcePile[sourcePile.length - 1];
                    if (!newTopCard.isFaceUp) {
                        newTopCard.isFaceUp = true;
                        this.gameState.score += 5;
                    }
                }
                
                this.gameState.moves++;
                
                // æ£€æŸ¥å®Œæ•´åºåˆ—
                const targetPile = this.gameState.tableauPiles[targetPileIndex];
                if (this.checkCompleteSequence(targetPile)) {
                    const completedSequence = targetPile.splice(targetPile.length - 13, 13);
                    this.gameState.foundations.push(completedSequence);
                    this.gameState.score += 100;
                    this.gameState.completedSequences++;
                    
                    // ç¿»å¼€ç§»é™¤åºåˆ—åçš„æ–°é¡¶ç‰Œ
                    if (targetPile.length > 0) {
                        const newTopCard = targetPile[targetPile.length - 1];
                        if (!newTopCard.isFaceUp) {
                            newTopCard.isFaceUp = true;
                            this.gameState.score += 5;
                        }
                    }
                    
                    this.checkWinState();
                }
                
                // é‡æ–°æ¸²æŸ“æ¸¸æˆ
                this.renderGame();
            }

            returnCardsToOriginalPosition() {
                if (!this.originalPositions || this.originalPositions.length === 0) return;
                
                this.originalPositions.forEach((pos, index) => {
                    const element = pos.element;
                    element.style.transition = 'all 0.3s ease';
                    element.style.position = 'absolute';
                    element.style.top = pos.top;
                    element.style.left = pos.left || '0px';
                    element.style.zIndex = pos.zIndex || 'auto';
                });
                
                // æ¸…ç†è¿‡æ¸¡æ•ˆæœ
                setTimeout(() => {
                    this.originalPositions.forEach(pos => {
                        pos.element.style.transition = '';
                    });
                    this.renderGame();
                }, 300);
            }

            cancelDrag() {
                if (this.isDragging) {
                    this.returnCardsToOriginalPosition();
                    this.cleanupDrag();
                }
            }

            cleanupDrag() {
                console.log('æ¸…ç†æ‹–æ‹½çŠ¶æ€'); // è°ƒè¯•æ—¥å¿—
                
                // ç§»é™¤é«˜äº®
                document.querySelectorAll('.tableau-pile.drag-over').forEach(pile => {
                    pile.classList.remove('drag-over');
                });
                
                // é‡ç½®æ‹–æ‹½çŠ¶æ€
                if (this.draggedCards && this.draggedCards.length > 0) {
                    this.draggedCards.forEach(card => {
                        if (card && card.classList) {
                            card.classList.remove('dragging');
                            card.style.pointerEvents = '';
                            card.style.cursor = '';
                        }
                    });
                }
                
                // é‡ç½®å…¨å±€çŠ¶æ€
                this.draggedCards = null;
                this.isDragging = false;
                this.originalPositions = [];
                this.originalPileIndex = null;
                this.originalCardIndex = null;
                this.offsetX = 0;
                this.offsetY = 0;
                
                // æ¢å¤é¡µé¢æ ·å¼
                document.body.style.userSelect = '';
                document.body.style.cursor = '';
            }

            showHint() {
                const hints = [];
                
                for (let pileIndex = 0; pileIndex < 10; pileIndex++) {
                    const pile = this.gameState.tableauPiles[pileIndex];
                    if (pile.length === 0) continue;
                    
                    const topCard = pile[pile.length - 1];
                    if (!topCard.isFaceUp) continue;
                    
                    for (let targetIndex = 0; targetIndex < 10; targetIndex++) {
                        if (targetIndex === pileIndex) continue;
                        
                        if (this.isValidMove([topCard], targetIndex)) {
                            hints.push(`å¯ä»¥å°† ${topCard.name}${this.getSuitSymbol(topCard.suit)} ä»ç¬¬${pileIndex + 1}æ¡©ç§»åŠ¨åˆ°ç¬¬${targetIndex + 1}æ¡©`);
                        }
                    }
                }
                
                if (hints.length > 0) {
                    alert(hints[0]);
                } else {
                    alert("æ²¡æœ‰æ‰¾åˆ°å¯è¡Œçš„ç§»åŠ¨ï¼Œå°è¯•å‘ç‰Œæˆ–é‡æ–°æ’åˆ—");
                }
            }

            getSuitSymbol(suit) {
                const symbols = { 'spades': 'â™ ', 'hearts': 'â™¥', 'clubs': 'â™£', 'diamonds': 'â™¦' };
                return symbols[suit] || suit;
            }

            winGame() {
                clearInterval(this.timerInterval);
                
                const timeBonus = Math.max(0, 1000 - Math.floor((Date.now() - this.startTime) / 1000));
                const finalScore = this.gameState.score + timeBonus;
                
                const elapsedTime = Date.now() - this.startTime;
                const minutes = Math.floor(elapsedTime / 60000);
                const seconds = Math.floor((elapsedTime % 60000) / 1000);
                const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                
                document.getElementById('final-time').textContent = formattedTime;
                document.getElementById('final-moves').textContent = this.gameState.moves;
                document.getElementById('final-score').textContent = finalScore;
                
                document.getElementById('fireworks').style.display = 'block';
                document.getElementById('win-message').style.display = 'block';
                
                this.startFireworks();
            }

            startFireworks() {
                const canvas = document.getElementById('fireworks');
                const ctx = canvas.getContext('2d');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                let particles = [];
                let animationId;
                
                const random = (min, max) => Math.random() * (max - min) + min;
                
                const createFirework = () => {
                    const x = random(100, canvas.width - 100);
                    const y = random(50, canvas.height / 2);
                    const colors = ['#30D158', '#0A84FF', '#AF52DE', '#FF9500', '#FF3B30', '#64D2FF'];
                    
                    for (let i = 0; i < 30; i++) {
                        particles.push({
                            x: x,
                            y: y,
                            vx: random(-6, 6),
                            vy: random(-6, 6),
                            life: 60,
                            maxLife: 60,
                            color: colors[Math.floor(Math.random() * colors.length)],
                            size: random(2, 4)
                        });
                    }
                };
                
                const animate = () => {
                    ctx.fillStyle = 'rgba(28, 28, 30, 0.1)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    particles.forEach((particle, index) => {
                        particle.x += particle.vx;
                        particle.y += particle.vy;
                        particle.vy += 0.15;
                        particle.life--;
                        
                        const alpha = particle.life / particle.maxLife;
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = particle.color;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * alpha, 0, Math.PI * 2);
                        ctx.fill();
                        
                        if (particle.life <= 0) {
                            particles.splice(index, 1);
                        }
                    });
                    
                    if (Math.random() < 0.04) {
                        createFirework();
                    }
                    
                    ctx.globalAlpha = 1;
                    animationId = requestAnimationFrame(animate);
                };
                
                animate();
                
                setTimeout(() => {
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                    }
                }, 8000);
            }

            restartGame() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                }
                
                document.getElementById('fireworks').style.display = 'none';
                document.getElementById('win-message').style.display = 'none';
                
                this.initializeGame();
            }
        }

        // Initialize the game
        console.log('å‡†å¤‡åˆå§‹åŒ–SpiderSolitaireå®ä¾‹'); // è°ƒè¯•æ—¥å¿—
        const game = new SpiderSolitaire();
        console.log('SpiderSolitaireå®ä¾‹åˆ›å»ºå®Œæˆ'); // è°ƒè¯•æ—¥å¿—
        
        // ç¡®ä¿åœ¨å¼€å§‹æ¸¸æˆæ—¶æ­£ç¡®åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMåŠ è½½å®Œæˆï¼Œæ¸¸æˆå‡†å¤‡å°±ç»ª');
            
            // æ£€æŸ¥å…³é”®DOMå…ƒç´ 
            const gameBoard = document.getElementById('game-board');
            const stockPile = document.getElementById('stock-pile');
            const startBtn = document.getElementById('start-game-btn');
            
            console.log('æ¸¸æˆé¢æ¿:', gameBoard ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
            console.log('åº“å­˜æ¡©:', stockPile ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
            console.log('å¼€å§‹æŒ‰é’®:', startBtn ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
            
            // æ£€æŸ¥tableauæ¡©
            for (let i = 0; i < 10; i++) {
                const pile = document.getElementById(`pile-${i}`);
                console.log(`æ¡© ${i}:`, pile ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
            }
        });
        
        // Prevent memory leaks on page unload
        window.addEventListener('beforeunload', () => {
            if (game.timerInterval) {
                clearInterval(game.timerInterval);
            }
            if (game.animationFrameId) {
                cancelAnimationFrame(game.animationFrameId);
            }
        });
    </script>
</body>
</html>
