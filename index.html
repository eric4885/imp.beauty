<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imp Beauty - Spider Solitaire</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --card-width: 100px;
            --card-height: calc(var(--card-width) * 1.4);
            --card-radius: 8px;
            --card-bg-light: #F9FAFB;
            --card-bg-dark: #2C2C2E;
            --card-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            --red-suit: #FF3B30;
            --black-suit: #1C1C1E;
        }

        body {
            background-color: #1C1C1E;
            overflow-x: hidden;
        }

        .card-container {
            width: var(--card-width);
            height: var(--card-height);
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            cursor: pointer;
            perspective: 1000px;
        }
        
        .card-container.transitioning {
            transition: transform 0.6s, top 0.3s ease, left 0.3s ease;
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: var(--card-radius);
            box-shadow: var(--card-shadow);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }

        .card-front {
            background-color: var(--card-bg-light);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: var(--black-suit);
        }
        .card-front.is-red {
            color: var(--red-suit);
        }
        .card-front .card-value {
            font-size: 2rem;
            font-weight: bold;
            line-height: 1;
        }
        .card-front .suit-symbol {
             font-size: 2.5rem;
        }

        .card-back {
            background-color: var(--card-bg-dark);
            transform: rotateY(180deg);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .card-container.is-flipped {
            transform: rotateY(180deg);
        }

        .tableau-pile {
            position: relative;
            padding-top: 20px;
            min-height: calc(var(--card-height) + 120px);
        }

        .tableau-pile .card-container {
            position: absolute;
            top: 0;
            left: 0;
            transition: top 0.3s ease;
        }

        #stock-pile {
            width: var(--card-width);
            height: var(--card-height);
            position: relative;
            cursor: pointer;
        }
        #stock-pile .card-back {
            position: absolute;
            top: 0;
            left: 0;
        }

        #foundations {
            display: flex;
            gap: 10px;
        }
        .foundation-pile {
             width: var(--card-width);
             height: var(--card-height);
        }
        .foundation-pile .card-container {
            position: relative;
        }

        #game-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            color: #E5E7EB;
        }

        #fireworks {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
            z-index: 9999;
        }
        #win-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 3rem;
            font-weight: bold;
            text-shadow: 0 0 10px black;
            display: none;
            text-align: center;
            z-index: 10000;
        }
        .btn {
            background: #0A84FF;
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.2s;
        }
        .btn:hover { background: #007AFF; }
    </style>
</head>
<body class="font-sans antialiased text-white">

    <div class="p-4 md:p-8">
        <h1 class="text-3xl md:text-4xl font-bold text-center mb-6 text-gray-200">Imp Beauty</h1>
        <p class="text-center text-gray-400 mb-6">Play Spider Solitaire online â€” a classic patience game with 4 suits.</p>

        <div id="game-stats" class="flex justify-between items-center mb-4 text-gray-300">
            <div>
                <span id="moves-counter">Moves: 0</span> |
                <span id="timer-counter">Time: 00:00</span>
            </div>
            <button id="restart-btn-top" class="btn">Restart</button>
        </div>
        
        <div class="flex justify-between items-start mb-4">
            <div id="stock-pile">
                <div class="card-face card-back">
                     <span class="text-white text-lg font-bold">IMP</span>
                </div>
            </div>
            
            <div id="foundations" class="flex flex-wrap justify-end gap-2">
                </div>
        </div>

        <div id="game-board" class="grid grid-cols-5 md:grid-cols-10 gap-2 md:gap-4">
            <div id="pile-0" class="tableau-pile"></div>
            <div id="pile-1" class="tableau-pile"></div>
            <div id="pile-2" class="tableau-pile"></div>
            <div id="pile-3" class="tableau-pile"></div>
            <div id="pile-4" class="tableau-pile"></div>
            <div id="pile-5" class="tableau-pile"></div>
            <div id="pile-6" class="tableau-pile"></div>
            <div id="pile-7" class="tableau-pile"></div>
            <div id="pile-8" class="tableau-pile"></div>
            <div id="pile-9" class="tableau-pile"></div>
        </div>
    </div>
    
    <canvas id="fireworks"></canvas>
    <div id="win-message">
        ðŸŽ‰ YOU WIN ðŸŽ‰<br>
        <button id="restart-btn-win" class="btn mt-4">Restart</button>
    </div>

    <script>
        class Card {
            constructor(suit, value, name) {
                this.suit = suit;
                this.value = value;
                this.name = name;
                this.isFaceUp = false;
            }
        }

        function createAndShuffleDeck() {
            const suits = ['spades', 'hearts', 'clubs', 'diamonds'];
            const values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];
            const cardNames = {
                1: 'Ace', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7',
                8: '8', 9: '9', 10: '10', 11: 'Jack', 12: 'Queen', 13: 'King'
            };

            let deck = [];
            for (let i = 0; i < 2; i++) {
                for (const suit of suits) {
                    for (const value of values) {
                        deck.push(new Card(suit, value, cardNames[value] || value.toString()));
                    }
                }
            }
            
            let currentIndex = deck.length, randomIndex;
            while (currentIndex !== 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [deck[currentIndex], deck[randomIndex]] = [deck[randomIndex], deck[currentIndex]];
            }
            return deck;
        }

        function initializeGame(shuffledDeck) {
            let gameState = {
                tableauPiles: Array.from({ length: 10 }, () => []),
                stockPiles: [],
                foundations: [],
                moves: 0
            };
            let cardIndex = 0;
            const cardsPerPile = [6, 6, 6, 6, 5, 5, 5, 5, 5, 5];

            for (let pileIndex = 0; pileIndex < 10; pileIndex++) {
                for (let i = 0; i < cardsPerPile[pileIndex]; i++) {
                    let card = shuffledDeck[cardIndex];
                    gameState.tableauPiles[pileIndex].push(card);
                    cardIndex++;
                }
                let topCard = gameState.tableauPiles[pileIndex][gameState.tableauPiles[pileIndex].length - 1];
                if (topCard) {
                    topCard.isFaceUp = true;
                }
            }
            gameState.stockPiles = shuffledDeck.slice(cardIndex);
            
            startTimer();
            
            return gameState;
        }

        let timerInterval;
        let startTime;

        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function updateTimer() {
            const elapsedTime = Date.now() - startTime;
            const minutes = Math.floor(elapsedTime / 60000);
            const seconds = Math.floor((elapsedTime % 60000) / 1000);
            
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(seconds).padStart(2, '0');
            
            document.getElementById('timer-counter').textContent = `æ—¶é—´: ${formattedMinutes}:${formattedSeconds}`;
        }
        
        function renderGame(gameState) {
            const suitSymbols = { 'spades': 'â™ ', 'hearts': 'â™¥', 'clubs': 'â™£', 'diamonds': 'â™¦' };
            const stockPileElement = document.getElementById('stock-pile');
            const movesCounterElement = document.getElementById('moves-counter');

            movesCounterElement.textContent = `æ­¥æ•°: ${gameState.moves}`;

            if (gameState.stockPiles.length > 0) {
                stockPileElement.style.opacity = 1;
                stockPileElement.style.cursor = 'pointer';
            } else {
                stockPileElement.style.opacity = 0.5;
                stockPileElement.style.cursor = 'not-allowed';
            }
            
            const foundationsElement = document.getElementById('foundations');
            foundationsElement.innerHTML = '';
            gameState.foundations.forEach(foundationPile => {
                 const foundationContainer = document.createElement('div');
                 foundationContainer.className = 'foundation-pile';
                 const topCard = foundationPile[foundationPile.length - 1];
                 const isRed = topCard.suit === 'hearts' || topCard.suit === 'diamonds';
                 foundationContainer.innerHTML = `
                     <div class="card-container is-flipped">
                          <div class="card-face card-back"></div>
                          <div class="card-face card-front ${isRed ? 'is-red' : ''}">
                              <span class="card-value self-start p-2">${topCard.name.charAt(0)}</span>
                              <span class="suit-symbol">${suitSymbols[topCard.suit]}</span>
                              <span class="card-value self-end p-2 rotate-180">${topCard.name.charAt(0)}</span>
                          </div>
                      </div>
                 `;
                 foundationsElement.appendChild(foundationContainer);
            });

            gameState.tableauPiles.forEach((pile, pileIndex) => {
                const pileElement = document.getElementById(`pile-${pileIndex}`);
                pileElement.innerHTML = '';
                
                pile.forEach((card, cardIndex) => {
                    const cardContainer = document.createElement('div');
                    cardContainer.className = `card-container`;
                    cardContainer.dataset.cardIndex = cardIndex;
                    cardContainer.dataset.pileIndex = pileIndex;
                    
                    const topOffset = cardIndex * 20;
                    cardContainer.style.top = `${topOffset}px`;
                    
                    const cardFront = document.createElement('div');
                    const isRed = card.suit === 'hearts' || card.suit === 'diamonds';
                    cardFront.className = `card-face card-front ${isRed ? 'is-red' : ''}`;
                    cardFront.innerHTML = `
                        <span class="card-value self-start p-2">${card.name.charAt(0)}</span>
                        <span class="suit-symbol">${suitSymbols[card.suit]}</span>
                        <span class="card-value self-end p-2 rotate-180">${card.name.charAt(0)}</span>
                    `;

                    const cardBack = document.createElement('div');
                    cardBack.className = 'card-face card-back';
                    cardBack.innerHTML = `<span class="text-white text-lg font-bold">IMP</span>`;

                    cardContainer.appendChild(cardBack);
                    cardContainer.appendChild(cardFront);

                    if (card.isFaceUp) {
                        cardContainer.classList.add('is-flipped');
                    }

                    if (card.isFaceUp) {
                        cardContainer.onmousedown = startDrag;
                        cardContainer.ontouchstart = startDrag;
                    }

                    pileElement.appendChild(cardContainer);
                });
            });
        }

        let draggedCards = null;
        let originalPileIndex, originalCardIndex;
        let originalX, originalY, offsetX, offsetY;
        let gameState;

        function checkWinState() {
            let totalFoundationCards = 0;
            gameState.foundations.forEach(pile => {
                totalFoundationCards += pile.length;
            });

            if (totalFoundationCards === 8) { // Assuming 8 sets of 13 cards, from 2 suits
                winGame();
            }
        }

        function checkCompleteSequence(pile) {
            if (pile.length < 13) return false;
            
            const lastCard = pile[pile.length - 1];
            if (lastCard.value !== 1) return false;

            for (let i = 1; i < 13; i++) {
                const currentCard = pile[pile.length - 1 - i];
                const prevCard = pile[pile.length - i];
                if (currentCard.value !== prevCard.value + 1 || currentCard.suit !== prevCard.suit) {
                    return false;
                }
            }
            return true;
        }

        function dealCards() {
            if (gameState.stockPiles.length === 0) {
                console.log("No more cards in the stock pile.");
                return;
            }

            for(let i = 0; i < 10; i++) {
                if (gameState.tableauPiles[i].length === 0) {
                    console.log("Cannot deal cards if there's an empty tableau pile.");
                    return;
                }
            }

            for (let i = 0; i < 10; i++) {
                const cardToDeal = gameState.stockPiles.shift();
                cardToDeal.isFaceUp = true;
                gameState.tableauPiles[i].push(cardToDeal);
            }
            
            gameState.moves++;
            renderGame(gameState);
        }

        function isValidMove(draggedCardsData, targetPile) {
            const targetPileIndex = parseInt(targetPile.id.replace('pile-', ''));
            const targetPileArray = gameState.tableauPiles[targetPileIndex];
            const firstDraggedCard = draggedCardsData[0];
            
            if (targetPileArray.length === 0) {
                return true;
            }

            const topCardOfTargetPile = targetPileArray[targetPileArray.length - 1];
            return firstDraggedCard.value === topCardOfTargetPile.value - 1;
        }

        function getDropTarget(x, y) {
            const piles = document.querySelectorAll('.tableau-pile');
            for (const pile of piles) {
                const rect = pile.getBoundingClientRect();
                if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                    return pile;
                }
            }
            return null;
        }

        function startDrag(e) {
            const cardElement = e.target.closest('.card-container');
            if (!cardElement || !cardElement.classList.contains('is-flipped')) {
                return;
            }
            e.preventDefault();

            originalPileIndex = parseInt(cardElement.dataset.pileIndex);
            originalCardIndex = parseInt(cardElement.dataset.cardIndex);
            
            const pile = gameState.tableauPiles[originalPileIndex];
            const sequence = pile.slice(originalCardIndex);
            
            let isSequenceValid = true;
            for(let i = 0; i < sequence.length - 1; i++) {
                if (sequence[i].value !== sequence[i+1].value + 1 || sequence[i].suit !== sequence[i+1].suit) {
                    isSequenceValid = false;
                    break;
                }
            }
            
            if (!isSequenceValid) {
                draggedCards = [cardElement];
            } else {
                const cardsToDrag = Array.from(cardElement.parentElement.children).slice(originalCardIndex);
                draggedCards = cardsToDrag;
            }

            const rect = cardElement.getBoundingClientRect();
            originalX = rect.left;
            originalY = rect.top;

            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.touches[0].clientY;

            offsetX = clientX - rect.left;
            offsetY = clientY - rect.top;

            draggedCards.forEach(card => {
                card.style.position = 'absolute';
                card.style.zIndex = 1000;
            });

            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);
        }

        function drag(e) {
            if (!draggedCards) return;
            e.preventDefault();

            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.touches[0].clientY;
            
            draggedCards.forEach((card, index) => {
                card.style.left = `${clientX - offsetX}px`;
                card.style.top = `${clientY - offsetY + (index * 20)}px`;
            });
        }

        function endDrag(e) {
            if (!draggedCards) return;

            const clientX = e.clientX || e.changedTouches[0].clientX;
            const clientY = e.changedTouches[0].clientY;

            const dropTarget = getDropTarget(clientX, clientY);
            
            const cardsDataToMove = gameState.tableauPiles[originalPileIndex].slice(originalCardIndex);

            if (dropTarget && isValidMove(cardsDataToMove, dropTarget)) {
                const targetPileIndex = parseInt(dropTarget.id.replace('pile-', ''));

                gameState.tableauPiles[originalPileIndex].splice(originalCardIndex);
                gameState.tableauPiles[targetPileIndex].push(...cardsDataToMove);

                const sourcePile = gameState.tableauPiles[originalPileIndex];
                if (sourcePile.length > 0) {
                    const newTopCard = sourcePile[sourcePile.length - 1];
                    newTopCard.isFaceUp = true;
                }
                
                gameState.moves++;

                const targetPile = gameState.tableauPiles[targetPileIndex];
                if (checkCompleteSequence(targetPile)) {
                    const completedSequence = targetPile.splice(targetPile.length - 13, 13);
                    gameState.foundations.push(completedSequence);
                    
                    const newTopCardAfterCompletion = targetPile[targetPile.length - 1];
                    if (newTopCardAfterCompletion && !newTopCardAfterCompletion.isFaceUp) {
                        newTopCardAfterCompletion.isFaceUp = true;
                    }
                    
                    checkWinState();
                }

                renderGame(gameState);

            } else {
                draggedCards.forEach((card, index) => {
                    const initialTop = parseFloat(card.dataset.cardIndex) * 20;
                    card.style.top = `${initialTop}px`;
                    card.style.left = '';
                    card.style.transition = 'top 0.3s ease, left 0.3s ease';
                });
                setTimeout(() => renderGame(gameState), 300);
            }

            draggedCards = null;
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('touchmove', drag);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchend', endDrag);
        }

        // ðŸŽ† Fireworks + Win Message
        function winGame(){
            clearInterval(timerInterval);
            document.getElementById("fireworks").style.display="block";
            document.getElementById("win-message").style.display="block";
            startFireworks();
        }

        function startFireworks(){
            const canvas=document.getElementById("fireworks");
            const ctx=canvas.getContext("2d");
            canvas.width=window.innerWidth;canvas.height=window.innerHeight;
            let particles=[];
            function random(min,max){return Math.random()*(max-min)+min;}
            function createFirework(){
                let x=random(100,canvas.width-100),y=random(50,canvas.height/2);
                for(let i=0;i<100;i++){
                    particles.push({x,y,angle:Math.random()*2*Math.PI,speed:random(2,5),life:100,color:`hsl(${Math.random()*360},100%,60%)`});
                }
            }
            function animate(){
                ctx.clearRect(0,0,canvas.width,canvas.height);
                particles.forEach((p,i)=>{
                    p.x+=Math.cos(p.angle)*p.speed;
                    p.y+=Math.sin(p.angle)*p.speed+0.5;
                    p.life--;
                    ctx.fillStyle=p.color;
                    ctx.fillRect(p.x,p.y,2,2);
                    if(p.life<=0) particles.splice(i,1);
                });
                if(Math.random()<0.05) createFirework();
                requestAnimationFrame(animate);
            }
            animate();
        }

        // ðŸ”„ Restart game
        function restartGame(){
            clearInterval(timerInterval);
            const shuffledDeck = createAndShuffleDeck();
            gameState = initializeGame(shuffledDeck);
            document.getElementById("fireworks").style.display="none";
            document.getElementById("win-message").style.display="none";
            renderGame(gameState);
        }
        
        document.getElementById("stock-pile").onclick = dealCards;
        document.getElementById("restart-btn-top").onclick = restartGame;
        document.getElementById("restart-btn-win").onclick = restartGame;

        const shuffledDeck = createAndShuffleDeck();
        gameState = initializeGame(shuffledDeck);
        renderGame(gameState);
    </script>
</body>
</html>
